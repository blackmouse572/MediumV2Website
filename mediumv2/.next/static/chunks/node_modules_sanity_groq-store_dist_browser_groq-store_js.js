/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "../node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("function e(e){return e&&\"object\"==typeof e&&\"default\"in e?e.default:e}var r=e(__webpack_require__(/*! groq */ \"../node_modules/groq/lib/groq.js\")),t=e(__webpack_require__(/*! fast-deep-equal */ \"../node_modules/fast-deep-equal/index.js\")),n=__webpack_require__(/*! throttle-debounce */ \"../node_modules/throttle-debounce/cjs/index.js\"),o=__webpack_require__(/*! groq-js */ \"../node_modules/groq-js/dist/groq-js.esm.js\"),i=__webpack_require__(/*! mendoza */ \"../node_modules/mendoza/lib/esm/index.js\");function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function s(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return i.addEventListener(\"welcome\",t.open,!1),i.addEventListener(\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)}),!1),i.addEventListener(\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))},!1),i.addEventListener(\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))},!1),{unsubscribe:function(){return Promise.resolve(i.close())}}}function c(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function a(e,r){var t=u({},e);return delete t._rev,i.applyPatch(t,r)}function f(){return Promise.resolve()}function d(){var e,r,t=(e=[\"*[_id == $id][0]\"],r||(r=e.slice(0)),e.raw=r,e);return d=function(){return t},t}function v(e,r,t){if(!e.s){if(t instanceof l){if(!t.s)return void(t.o=v.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(v.bind(null,e,r),v.bind(null,e,2));e.s=r,e.v=t;var n=e.o;n&&n(e)}}var l=function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{v(n,1,i(this.v))}catch(e){v(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?v(n,1,r?r(o):o):t?v(n,1,t(o)):v(n,2,o)}catch(e){v(n,2,e)}},n},e}();function h(e){return e instanceof l&&1&e.s}var m=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var c=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),a=0;a<c.length-1;++a){var f=c[a].trim();if(0===f.length)return Promise.resolve();try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=c[c.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body).getReader(),u=[],s=function(e,r){var t;do{var n=e();if(n&&n.then){if(!h(n)){t=!0;break}n=n.v}var o=r();if(h(o)&&(o=o.v),!o)return n}while(!o.then);var i=new l,u=v.bind(null,i,2);return(t?n.then(s):o.then(c)).then(void 0,u),i;function s(t){for(n=t;h(o=r())&&(o=o.v),o;){if(o.then)return void o.then(c).then(void 0,u);if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}}v(i,1,n)}function c(t){if(t){do{if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}if(h(t=r())&&(t=t.v),!t)return void v(i,1,n)}while(!t.then);t.then(c).then(void 0,u)}else v(i,1,n)}}(function(){return Promise.resolve(i.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&u.push(n),o&&u.length>o)throw i.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return s&&s.then?s.then(function(e){return u}):u}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};exports.groq=r,exports.groqStore=function(e){if(function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}(),e.token)throw new Error(\"`token` option not currently supported in browser\");return function(e,i){var v,l=function(e,r){try{return Promise.resolve(h()).then(function(){var t=o.parse(e,{params:r});return Promise.resolve(o.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})}catch(e){return Promise.reject(e)}},h=function(){try{return v||(v=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,d=e.dataset,v=e.overlayDrafts,l=e.documentLimit;if(!e.listen)return{unsubscribe:f,loaded:n({projectId:i,dataset:d,documentLimit:l}).then(j).then(f)};var h,m,p,w,b,g,y=new Map,P=[],E=new Promise(function(e,r){m=e,p=r});return{unsubscribe:s(o,e,{next:function(e){h?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=y.get(e.documentId)||null;!function(e,r){var t=y.get(e),n=h||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),y.set(e,r)):r?(n.splice(o,1,r),y.set(e,r)):(n.splice(o,1),y.delete(e))}(e.documentId,a(r,e.effects.apply))}}(e),function(e,r){clearTimeout(g),b!==r.transactionId&&w?(j(w),b=void 0):(b=r.transactionId,w=e.slice()),g=setTimeout(j,25,e.slice())}(h,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:d,documentLimit:l})).then(function(e){(h=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=a(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return y.set(e._id,e)}),j(h),m()})}catch(e){return Promise.reject(e)}},error:function(e){return p(e)}}).unsubscribe,loaded:E};function j(e){w=void 0,g=void 0,b=void 0,r(v?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(c(e));e._id.startsWith(\"drafts.\")?r.set(c(e),function(e){return u({},e,{_id:c(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},i)),Promise.resolve(v.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=n.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return l(e.query,e.params).then(function(r){\"previousResult\"in e&&t(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:l,getDocument:function(e){try{return Promise.resolve(h()).then(function(){return l(r(d()),{id:e})})}catch(e){return Promise.reject(e)}},getDocuments:function(e){try{return Promise.resolve(h()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return l(\"[\"+r+\"]\")})}catch(e){return Promise.reject(e)}},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),v?v.unsubscribe():Promise.resolve()}}}(e,{EventSource:window.EventSource,getDocuments:m})};\n//# sourceMappingURL=groq-store.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLHdEQUF3RCxRQUFRLG1CQUFPLENBQUMsOENBQU0sT0FBTyxtQkFBTyxDQUFDLGlFQUFpQixLQUFLLG1CQUFPLENBQUMseUVBQW1CLElBQUksbUJBQU8sQ0FBQyw0REFBUyxJQUFJLG1CQUFPLENBQUMseURBQVMsRUFBRSxhQUFhLG9DQUFvQyxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsU0FBUyx3QkFBd0Isa0JBQWtCLDJIQUEySCw4QkFBOEIsMEJBQTBCLFFBQVEsRUFBRSxtR0FBbUcsTUFBTSxJQUFJLHFCQUFxQixTQUFTLE9BQU8sS0FBSyxvREFBb0QsTUFBTSxVQUFVLElBQUkscUJBQXFCLFNBQVMseUVBQXlFLCtFQUErRSw0Q0FBNEMsOEhBQThILGtEQUFrRCwwQkFBMEIsMEdBQTBHLE1BQU0sdUJBQXVCLG9DQUFvQyxjQUFjLHdEQUF3RCxnQkFBZ0IsVUFBVSxJQUFJLHVDQUF1QyxhQUFhLHlCQUF5QixhQUFhLCtEQUErRCxvQkFBb0IsU0FBUyxHQUFHLGtCQUFrQixTQUFTLG1CQUFtQiwwQ0FBMEMsbUJBQW1CLG1FQUFtRSxZQUFZLFVBQVUsU0FBUyxpQkFBaUIsY0FBYyxzQ0FBc0MscUJBQXFCLE1BQU0sY0FBYyxNQUFNLElBQUksaUJBQWlCLFNBQVMsU0FBUyxTQUFTLFlBQVksMEJBQTBCLElBQUksVUFBVSw2Q0FBNkMsU0FBUyxVQUFVLEdBQUcsR0FBRyxHQUFHLGNBQWMsNkJBQTZCLGtCQUFrQiwwREFBMEQsSUFBSSw4RUFBOEUsaUNBQWlDLDBCQUEwQixRQUFRLG9CQUFvQixjQUFjLHNCQUFzQiwyREFBMkQsV0FBVyxhQUFhLG1CQUFtQiwyQkFBMkIsa0JBQWtCLGdCQUFnQiwyQkFBMkIsNEJBQTRCLElBQUksa0pBQWtKLGdDQUFnQyxVQUFVLG1CQUFtQixhQUFhLEtBQUssa0JBQWtCLHlDQUF5QyxJQUFJLHlCQUF5QixTQUFTLHlDQUF5QywrQ0FBK0Msb0JBQW9CLElBQUksaURBQWlELEtBQUssRUFBRSxTQUFTLFlBQVksb0NBQW9DLGVBQWUsV0FBVyxFQUFFLG9EQUFvRCxVQUFVLFNBQVMsMEJBQTBCLG9CQUFvQixrQkFBa0IsRUFBRSxVQUFVLEVBQUUsMENBQTBDLE1BQU0sR0FBRyxVQUFVLGNBQWMsVUFBVSxLQUFLLE1BQU0sTUFBTSxVQUFVLDZCQUE2QixlQUFlLCtCQUErQiwrQ0FBK0MsY0FBYyxRQUFRLG9CQUFvQixFQUFFLCtDQUErQyxvQkFBb0IsOENBQThDLE9BQU8sU0FBUyxjQUFjLE1BQU0sR0FBRyxvQkFBb0IsOENBQThDLE1BQU0sNkNBQTZDLGVBQWUseUJBQXlCLGVBQWUsWUFBWSxrREFBa0QsZUFBZSw4SUFBOEkscUVBQXFFLHVLQUF1SyxFQUFFLFlBQVksY0FBYyxFQUFFLG9DQUFvQyxTQUFTLElBQUksaUJBQWlCLG9FQUFvRSxzSUFBc0ksTUFBTSxFQUFFLEdBQUcsK0JBQStCLEVBQUUsU0FBUywyQkFBMkIsWUFBWSxHQUFHLGlCQUFpQixhQUFhLGNBQWMsa0VBQWtFLHFCQUFxQixFQUFFLDRGQUE0RixnRkFBZ0YscUJBQXFCLHNCQUFzQixJQUFJLDRDQUE0QyxpQkFBaUIsU0FBUyxFQUFFLHFDQUFxQyxtQkFBbUIsb0JBQW9CLGVBQWUsRUFBRSxFQUFFLFNBQVMsMEJBQTBCLGNBQWMsSUFBSSw2QkFBNkIsbUdBQW1HLG9CQUFvQix3QkFBd0Isc0NBQXNDLG1CQUFtQiwyREFBMkQsUUFBUSxFQUFFLE9BQU8sbUJBQW1CLGlCQUFpQixlQUFlLDhDQUE4QyxnQ0FBZ0MsZUFBZSwyQ0FBMkMsNEZBQTRGLHFDQUFxQyxrQkFBa0Isb0hBQW9ILGlCQUFpQixpQkFBaUIsSUFBSSwwQkFBMEIsc0NBQXNDLG9CQUFvQixpQkFBaUIsY0FBYyw2QkFBNkIsOEJBQThCLGdDQUFnQywwQkFBMEIseUJBQXlCLGlCQUFpQixFQUFFLE1BQU0sYUFBYSxzQkFBc0IsbUVBQW1FLDZCQUE2QixpRUFBaUUsSUFBSSwyQkFBMkIsc0JBQXNCLFdBQVcsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsYUFBYSx3QkFBd0IsY0FBYywyQ0FBMkMsY0FBYyw2QkFBNkIsa0JBQWtCLG1EQUFtRCxXQUFXLElBQUksU0FBUyxFQUFFLHVCQUF1Qix5QkFBeUIsUUFBUSxlQUFlLFFBQVEsZ0RBQWdELEVBQUUsU0FBUywwQkFBMEIsMkRBQTJELGFBQWEsT0FBTyxjQUFjLDRDQUE0Qyx1RkFBdUYsb0JBQW9CLGNBQWMsRUFBRSxPQUFPLGdDQUFnQyxJQUFJLDRDQUE0QyxpQkFBaUIsS0FBSyxFQUFFLEVBQUUsU0FBUywwQkFBMEIsMEJBQTBCLElBQUksNENBQTRDLHdCQUF3Qiw2QkFBNkIsY0FBYyxvQkFBb0IsRUFBRSxTQUFTLDBCQUEwQiwyQkFBMkIsZ0ZBQWdGLE9BQU8sNkJBQTZCLFVBQVUsU0FBUyxhQUFhLHVCQUF1Qiw4REFBOEQsa0JBQWtCLHdEQUF3RCxJQUFJLDhDQUE4QztBQUM1bFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2dyb3Etc3RvcmUvZGlzdC9icm93c2VyL2dyb3Etc3RvcmUuanM/Y2I5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplfXZhciByPWUocmVxdWlyZShcImdyb3FcIikpLHQ9ZShyZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpKSxuPXJlcXVpcmUoXCJ0aHJvdHRsZS1kZWJvdW5jZVwiKSxvPXJlcXVpcmUoXCJncm9xLWpzXCIpLGk9cmVxdWlyZShcIm1lbmRvemFcIik7ZnVuY3Rpb24gdSgpe3JldHVybih1PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gcyhlLHIsdCl7dmFyIG4sbz1yLnRva2VuLGk9bmV3IGUoXCJodHRwczovL1wiK3IucHJvamVjdElkK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vXCIrci5kYXRhc2V0K1wiP3F1ZXJ5PSomZWZmZWN0Rm9ybWF0PW1lbmRvemFcIix7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6bz97QXV0aG9yaXphdGlvbjpcIkJlYXJlciBcIitvfTp2b2lkIDB9KTtyZXR1cm4gaS5hZGRFdmVudExpc3RlbmVyKFwid2VsY29tZVwiLHQub3BlbiwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwibXV0YXRpb25cIiwobj10Lm5leHQsZnVuY3Rpb24oZSl7dmFyIHI7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybn1uKHIpfSksITEpLGkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5uZWxFcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByO2kuY2xvc2UoKTt0cnl7cj1KU09OLnBhcnNlKGUuZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgdC5lcnJvcihuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgbGlzdGVuZXIgbWVzc2FnZVwiKSl9dC5lcnJvcihuZXcgRXJyb3Ioci5tZXNzYWdlfHxyLmVycm9yfHxcIkxpc3RlbmVyIHJldHVybmVkIEhUVFAgXCIrci5zdGF0dXNDb2RlKSl9LCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbi5vcmlnaW4sbj1yP1wiLCBhbmQgdGhhdCB0aGUgQ09SUy1vcmlnaW4gKFwiK3IrXCIpIGlzIGFsbG93ZWRcIjpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP1wiIChcIitlLm1lc3NhZ2UrXCIpXCI6XCJcIjt0LmVycm9yKG5ldyBFcnJvcihcIkVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3RcIituK28pKX0sITEpLHt1bnN1YnNjcmliZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5jbG9zZSgpKX19fWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGEoZSxyKXt2YXIgdD11KHt9LGUpO3JldHVybiBkZWxldGUgdC5fcmV2LGkuYXBwbHlQYXRjaCh0LHIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gZCgpe3ZhciBlLHIsdD0oZT1bXCIqW19pZCA9PSAkaWRdWzBdXCJdLHJ8fChyPWUuc2xpY2UoMCkpLGUucmF3PXIsZSk7cmV0dXJuIGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiB2KGUscix0KXtpZighZS5zKXtpZih0IGluc3RhbmNlb2YgbCl7aWYoIXQucylyZXR1cm4gdm9pZCh0Lm89di5iaW5kKG51bGwsZSxyKSk7MSZyJiYocj10LnMpLHQ9dC52fWlmKHQmJnQudGhlbilyZXR1cm4gdm9pZCB0LnRoZW4odi5iaW5kKG51bGwsZSxyKSx2LmJpbmQobnVsbCxlLDIpKTtlLnM9cixlLnY9dDt2YXIgbj1lLm87biYmbihlKX19dmFyIGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKHIsdCl7dmFyIG49bmV3IGUsbz10aGlzLnM7aWYobyl7dmFyIGk9MSZvP3I6dDtpZihpKXt0cnl7dihuLDEsaSh0aGlzLnYpKX1jYXRjaChlKXt2KG4sMixlKX1yZXR1cm4gbn1yZXR1cm4gdGhpc31yZXR1cm4gdGhpcy5vPWZ1bmN0aW9uKGUpe3RyeXt2YXIgbz1lLnY7MSZlLnM/dihuLDEscj9yKG8pOm8pOnQ/dihuLDEsdChvKSk6dihuLDIsbyl9Y2F0Y2goZSl7dihuLDIsZSl9fSxufSxlfSgpO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBsJiYxJmUuc312YXIgbT1mdW5jdGlvbihlKXt2YXIgcj1lLnByb2plY3RJZCx0PWUuZGF0YXNldCxuPWUudG9rZW4sbz1lLmRvY3VtZW50TGltaXQ7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZmV0Y2goXCJodHRwczovL1wiK3IrXCIuYXBpLnNhbml0eS5pby92MS9kYXRhL2V4cG9ydC9cIit0LHtjcmVkZW50aWFsczpcImluY2x1ZGVcIixoZWFkZXJzOm4/e0F1dGhvcml6YXRpb246XCJCZWFyZXIgXCIrbn06dm9pZCAwfSkpLnRoZW4oZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihyKXt2YXIgdCxuLGk9ZnVuY3Rpb24oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlYWQgYm9keSBmcm9tIHJlc3BvbnNlXCIpO3ZhciByLHQ9ITE7ZnVuY3Rpb24gbigpe3Q9ITAsciYmci5jYW5jZWwoKX1yZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydDpmdW5jdGlvbihvKXtyPWUuZ2V0UmVhZGVyKCk7dmFyIGk9bmV3IFRleHREZWNvZGVyLHU9XCJcIjtyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIGUocyl7dHJ5e2lmKHMuZG9uZSlyZXR1cm4gdD9Qcm9taXNlLnJlc29sdmUoKTowPT09KHU9dS50cmltKCkpLmxlbmd0aD8oby5jbG9zZSgpLFByb21pc2UucmVzb2x2ZSgpKTooby5lbnF1ZXVlKEpTT04ucGFyc2UodSkpLG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk7Zm9yKHZhciBjPSh1Kz1pLmRlY29kZShzLnZhbHVlLHtzdHJlYW06ITB9KSkuc3BsaXQoXCJcXG5cIiksYT0wO2E8Yy5sZW5ndGgtMTsrK2Epe3ZhciBmPWNbYV0udHJpbSgpO2lmKDA9PT1mLmxlbmd0aClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKGYpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuKCksUHJvbWlzZS5yZXNvbHZlKCl9fWlmKHU9Y1tjLmxlbmd0aC0xXSwhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dmFyIGQ9ZnVuY3Rpb24odCxuKXt0cnl7dmFyIG89UHJvbWlzZS5yZXNvbHZlKHIucmVhZCgpKS50aGVuKGZ1bmN0aW9uKHIpe2Uocil9KX1jYXRjaChlKXtyZXR1cm4gbihlKX1yZXR1cm4gbyYmby50aGVuP28udGhlbih2b2lkIDAsbik6b30oMCxmdW5jdGlvbihlKXtvLmVycm9yKGUpfSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShkJiZkLnRoZW4/ZC50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkuY2F0Y2goZnVuY3Rpb24oZSl7cmV0dXJuIG8uZXJyb3IoZSl9KX0sY2FuY2VsOm59KX0oZS5ib2R5KS5nZXRSZWFkZXIoKSx1PVtdLHM9ZnVuY3Rpb24oZSxyKXt2YXIgdDtkb3t2YXIgbj1lKCk7aWYobiYmbi50aGVuKXtpZighaChuKSl7dD0hMDticmVha31uPW4udn12YXIgbz1yKCk7aWYoaChvKSYmKG89by52KSwhbylyZXR1cm4gbn13aGlsZSghby50aGVuKTt2YXIgaT1uZXcgbCx1PXYuYmluZChudWxsLGksMik7cmV0dXJuKHQ/bi50aGVuKHMpOm8udGhlbihjKSkudGhlbih2b2lkIDAsdSksaTtmdW5jdGlvbiBzKHQpe2ZvcihuPXQ7aChvPXIoKSkmJihvPW8udiksbzspe2lmKG8udGhlbilyZXR1cm4gdm9pZCBvLnRoZW4oYykudGhlbih2b2lkIDAsdSk7aWYoKG49ZSgpKSYmbi50aGVuKXtpZighaChuKSlyZXR1cm4gdm9pZCBuLnRoZW4ocykudGhlbih2b2lkIDAsdSk7bj1uLnZ9fXYoaSwxLG4pfWZ1bmN0aW9uIGModCl7aWYodCl7ZG97aWYoKG49ZSgpKSYmbi50aGVuKXtpZighaChuKSlyZXR1cm4gdm9pZCBuLnRoZW4ocykudGhlbih2b2lkIDAsdSk7bj1uLnZ9aWYoaCh0PXIoKSkmJih0PXQudiksIXQpcmV0dXJuIHZvaWQgdihpLDEsbil9d2hpbGUoIXQudGhlbik7dC50aGVuKGMpLnRoZW4odm9pZCAwLHUpfWVsc2UgdihpLDEsbil9fShmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5yZWFkKCkpLnRoZW4oZnVuY3Rpb24oZSl7aWYoZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZcImVycm9yXCJpbiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5lcnJvciYmbnVsbCE9PWUuZXJyb3ImJlwiZGVzY3JpcHRpb25cImluIGUuZXJyb3ImJlwic3RyaW5nXCI9PXR5cGVvZiBlLmVycm9yLmRlc2NyaXB0aW9uJiYhKFwiX2lkXCJpbiBlKX0obj0odD1lKS52YWx1ZSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFwiK24uZXJyb3IpO2lmKG4mJiFuLl9pZC5zdGFydHNXaXRoKFwiXy5cIikmJnUucHVzaChuKSxvJiZ1Lmxlbmd0aD5vKXRocm93IGkuY2FuY2VsKFwiUmVhY2hlZCBkb2N1bWVudCBsaW1pdFwiKSxuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogUmVhY2hlZCBsaW1pdCBvZiBcIitvK1wiIGRvY3VtZW50c1wiKX0pfSxmdW5jdGlvbigpe3JldHVybiF0LmRvbmV9KTtyZXR1cm4gcyYmcy50aGVuP3MudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdX0pOnV9dmFyIHQ9ZnVuY3Rpb24oKXtpZigyMDAhPT1lLnN0YXR1cylyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuanNvbigpKS50aGVuKGZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIisoXCJvYmplY3RcIj09dHlwZW9mKHI9ZSkmJlwiZXJyb3JcImluIHImJlwibWVzc2FnZVwiaW4gcj9yLm1lc3NhZ2V8fHIuZXJyb3I6XCI8dW5rbm93biBlcnJvcj5cIikpO3ZhciByfSl9KCk7cmV0dXJuIHQmJnQudGhlbj90LnRoZW4ocik6cigpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX07ZXhwb3J0cy5ncm9xPXIsZXhwb3J0cy5ncm9xU3RvcmU9ZnVuY3Rpb24oZSl7aWYoZnVuY3Rpb24oKXt2YXIgZT1bXCJFdmVudFNvdXJjZVwiLFwiUmVhZGFibGVTdHJlYW1cIixcImZldGNoXCJdLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hKGUgaW4gd2luZG93KX0pO2lmKGUubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBub3Qgc3VwcG9ydGVkLiBNaXNzaW5nIGJyb3dzZXIgQVBJczogXCIrZS5qb2luKFwiLCBcIikpfSgpLGUudG9rZW4pdGhyb3cgbmV3IEVycm9yKFwiYHRva2VuYCBvcHRpb24gbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gYnJvd3NlclwiKTtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgdixsPWZ1bmN0aW9uKGUscil7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHQ9by5wYXJzZShlLHtwYXJhbXM6cn0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoby5ldmFsdWF0ZSh0LHtkYXRhc2V0Om0scGFyYW1zOnJ9KSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXQoKX0pfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0saD1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdnx8KHY9ZnVuY3Rpb24oZSxyLHQpe3ZhciBuPXQuZ2V0RG9jdW1lbnRzLG89dC5FdmVudFNvdXJjZSxpPWUucHJvamVjdElkLGQ9ZS5kYXRhc2V0LHY9ZS5vdmVybGF5RHJhZnRzLGw9ZS5kb2N1bWVudExpbWl0O2lmKCFlLmxpc3RlbilyZXR1cm57dW5zdWJzY3JpYmU6Zixsb2FkZWQ6bih7cHJvamVjdElkOmksZGF0YXNldDpkLGRvY3VtZW50TGltaXQ6bH0pLnRoZW4oaikudGhlbihmKX07dmFyIGgsbSxwLHcsYixnLHk9bmV3IE1hcCxQPVtdLEU9bmV3IFByb21pc2UoZnVuY3Rpb24oZSxyKXttPWUscD1yfSk7cmV0dXJue3Vuc3Vic2NyaWJlOnMobyxlLHtuZXh0OmZ1bmN0aW9uKGUpe2g/KGZ1bmN0aW9uKGUpe2lmKGUuZWZmZWN0cyYmIWUuZG9jdW1lbnRJZC5zdGFydHNXaXRoKFwiXy5cIikpe3ZhciByPXkuZ2V0KGUuZG9jdW1lbnRJZCl8fG51bGw7IWZ1bmN0aW9uKGUscil7dmFyIHQ9eS5nZXQoZSksbj1ofHxbXSxvPXQ/bi5pbmRleE9mKHQpOi0xOy0xPT09byYmcj8obi5wdXNoKHIpLHkuc2V0KGUscikpOnI/KG4uc3BsaWNlKG8sMSxyKSx5LnNldChlLHIpKToobi5zcGxpY2UobywxKSx5LmRlbGV0ZShlKSl9KGUuZG9jdW1lbnRJZCxhKHIsZS5lZmZlY3RzLmFwcGx5KSl9fShlKSxmdW5jdGlvbihlLHIpe2NsZWFyVGltZW91dChnKSxiIT09ci50cmFuc2FjdGlvbklkJiZ3PyhqKHcpLGI9dm9pZCAwKTooYj1yLnRyYW5zYWN0aW9uSWQsdz1lLnNsaWNlKCkpLGc9c2V0VGltZW91dChqLDI1LGUuc2xpY2UoKSl9KGgsZSkpOlAucHVzaChlKX0sb3BlbjpmdW5jdGlvbigpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4oe3Byb2plY3RJZDppLGRhdGFzZXQ6ZCxkb2N1bWVudExpbWl0Omx9KSkudGhlbihmdW5jdGlvbihlKXsoaD1mdW5jdGlvbihlLHIpe3ZhciB0PW5ldyBNYXA7cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcj10LmdldChlLmRvY3VtZW50SWQpfHxbXTtyLnB1c2goZSksdC5zZXQoZS5kb2N1bWVudElkLHIpfSksdC5mb3JFYWNoKGZ1bmN0aW9uKHIsdCl7dmFyIG49ZS5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiBlLl9pZD09PXR9KTtpZihuKXt2YXIgbz0hMSxpPW47ci5mb3JFYWNoKGZ1bmN0aW9uKGUpeyhvPW98fGUucHJldmlvdXNSZXY9PT1uLl9yZXYpJiZlLmVmZmVjdHMmJihpPWEoaSxlLmVmZmVjdHMuYXBwbHkpKX0pLGUuc3BsaWNlKGUuaW5kZXhPZihuKSwxLGkpfWVsc2UgY29uc29sZS53YXJuKFwiUmVjZWl2ZWQgbXV0YXRpb24gZm9yIG1pc3NpbmcgZG9jdW1lbnQgJXNcIix0KX0pLGV9KGUsUCkpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHkuc2V0KGUuX2lkLGUpfSksaihoKSxtKCl9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxlcnJvcjpmdW5jdGlvbihlKXtyZXR1cm4gcChlKX19KS51bnN1YnNjcmliZSxsb2FkZWQ6RX07ZnVuY3Rpb24gaihlKXt3PXZvaWQgMCxnPXZvaWQgMCxiPXZvaWQgMCxyKHY/ZnVuY3Rpb24oZSl7dmFyIHI9bmV3IE1hcDtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXIuZ2V0KGMoZSkpO2UuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP3Iuc2V0KGMoZSksZnVuY3Rpb24oZSl7cmV0dXJuIHUoe30sZSx7X2lkOmMoZSl9KX0oZSkpOnR8fHIuc2V0KGUuX2lkLGUpfSksQXJyYXkuZnJvbShyLnZhbHVlcygpKX0oZSk6ZSl9fShlLGZ1bmN0aW9uKGUpe209ZSxwKCl9LGkpKSxQcm9taXNlLnJlc29sdmUodi5sb2FkZWQpLnRoZW4oZnVuY3Rpb24oKXt9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxtPVtdLHA9bi50aHJvdHRsZShlLnN1YnNjcmlwdGlvblRocm90dGxlTXN8fDUwLGZ1bmN0aW9uKCl7dy5mb3JFYWNoKGIpfSksdz1bXTtmdW5jdGlvbiBiKGUpe3JldHVybiBsKGUucXVlcnksZS5wYXJhbXMpLnRoZW4oZnVuY3Rpb24ocil7XCJwcmV2aW91c1Jlc3VsdFwiaW4gZSYmdChlLnByZXZpb3VzUmVzdWx0LHIpfHwoZS5wcmV2aW91c1Jlc3VsdD1yLGUuY2FsbGJhY2sodm9pZCAwLHIpKX0pLmNhdGNoKGZ1bmN0aW9uKHIpe2UuY2FsbGJhY2socil9KX1yZXR1cm57cXVlcnk6bCxnZXREb2N1bWVudDpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShoKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbChyKGQoKSkse2lkOmV9KX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LGdldERvY3VtZW50czpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShoKCkpLnRoZW4oZnVuY3Rpb24oKXt2YXIgcj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4nKltfaWQgPT0gXCInK2UrJ1wiXVswXSd9KS5qb2luKFwiLFxcblwiKTtyZXR1cm4gbChcIltcIityK1wiXVwiKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LHN1YnNjcmliZTpmdW5jdGlvbihyLHQsbil7aWYoIWUubGlzdGVuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYHN1YnNjcmliZSgpYCB3aXRob3V0IGBsaXN0ZW46IHRydWVgXCIpO3ZhciBvPXtxdWVyeTpyLHBhcmFtczp0LGNhbGxiYWNrOm59O3cucHVzaChvKTt2YXIgaT0hMTtyZXR1cm4gYihvKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gaXx8KGk9ITAsdy5zcGxpY2Uody5pbmRleE9mKG8pLDEpKSxQcm9taXNlLnJlc29sdmUoKX19fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBwLmNhbmNlbCgpLHY/di51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGUse0V2ZW50U291cmNlOndpbmRvdy5FdmVudFNvdXJjZSxnZXREb2N1bWVudHM6bX0pfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3Etc3RvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@sanity/groq-store/dist/browser/groq-store.js\n");

/***/ }),

/***/ "../node_modules/fast-deep-equal/index.js":
/*!************************************************!*\
  !*** ../node_modules/fast-deep-equal/index.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcz9jMThmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/fast-deep-equal/index.js\n");

/***/ }),

/***/ "../node_modules/groq-js/dist/groq-js.esm.js":
/*!***************************************************!*\
  !*** ../node_modules/groq-js/dist/groq-js.esm.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate\": function() { return /* binding */ evaluateQuery; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nclass MarkProcessor {\n  constructor(string3, marks, parseOptions) {\n    this.allowBoost = false;\n    this.string = string3;\n    this.marks = marks;\n    this.index = 0;\n    this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`);\n    }\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    this.shift();\n    return this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1];\n    const curr = this.marks[this.index];\n    this.shift();\n    return this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str);\n  }\n  return null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n  const day = addLeadingZero(d.getUTCDate(), 2);\n  const hour = addLeadingZero(d.getUTCHours(), 2);\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`;\n  }\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  while (str.length < targetLength) {\n    str = `0${str}`;\n  }\n  return str;\n}\nfunction escapeRegExp(string3) {\n  return string3.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\")) {\n    if (part === \"*\") {\n      re.push(\"[^.]+\");\n    } else if (part === \"**\") {\n      re.push(\".*\");\n    } else {\n      re.push(escapeRegExp(part));\n    }\n  }\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  constructor(pattern) {\n    this.pattern = pattern;\n    this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nclass StreamValue {\n  constructor(generator) {\n    this.type = \"stream\";\n    this.generator = generator;\n    this.ticker = null;\n    this.isDone = false;\n    this.data = [];\n  }\n  isArray() {\n    return true;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this) {\n      result.push(await value.get());\n    }\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i];\n      }\n      if (this.isDone) {\n        return;\n      }\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker) {\n      return this.ticker;\n    }\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve;\n      });\n    };\n    const tick = () => {\n      currentResolver();\n      setupTicker();\n    };\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value);\n        tick();\n      }\n      this.isDone = true;\n      tick();\n    };\n    setupTicker();\n    fetch();\n    return this.ticker;\n  }\n}\nclass StaticValue {\n  constructor(data, type) {\n    this.data = data;\n    this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data)) {\n      return function* (data) {\n        for (const element of data) {\n          yield fromJS(element);\n        }\n      }(this.data);\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    if (date) {\n      return new StaticValue(new DateTime(date), \"datetime\");\n    }\n    return NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    copy.setTime(copy.getTime() + secs * 1e3);\n    return new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, \"number\");\n  }\n  return NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path2) {\n  return new StaticValue(path2, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value);\n      }\n    });\n  } else if (val === null || val === void 0) {\n    return NULL_VALUE;\n  }\n  return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  if (data === null || typeof data === \"undefined\") {\n    return \"null\";\n  }\n  if (Array.isArray(data)) {\n    return \"array\";\n  }\n  if (data instanceof Path) {\n    return \"path\";\n  }\n  if (data instanceof DateTime) {\n    return \"datetime\";\n  }\n  return typeof data;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  if (aType !== bType) {\n    return null;\n  }\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      if (a < b)\n        return -1;\n      if (a > b)\n        return 1;\n      return 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder;\n  }\n  let result = partialCompare(a, b);\n  if (result === null) {\n    result = 0;\n  }\n  return result;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false;\n  }\n  return patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  const termsRe = matchPatternRegex(text);\n  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n  return terms.map((term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\")}$`, \"i\"));\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\") {\n    cb(value.data);\n    return true;\n  }\n  if (value.isArray()) {\n    let success = true;\n    for await (const part of value) {\n      if (part.type === \"string\") {\n        cb(part.data);\n      } else {\n        success = false;\n      }\n    }\n    return success;\n  }\n  return false;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\") {\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  }\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\n    const boost2 = await execute(node.args[1], scope);\n    if (boost2.type === \"number\" && innerScore > 0) {\n      return innerScore + boost2.data;\n    }\n    return 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      if (leftScore === 0 || rightScore === 0)\n        return 0;\n      return leftScore + rightScore;\n    }\n    default: {\n      const res = await execute(node, scope);\n      return res.type === \"boolean\" && res.data === true ? 1 : 0;\n    }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope);\n  const pattern = await execute(right, scope);\n  let tokens = [];\n  let terms = [];\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part));\n  });\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part));\n  });\n  if (!didSucceed) {\n    return 0;\n  }\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0;\n  }\n  let score2 = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score2 += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score2;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\") {\n    return blockText(value.data);\n  } else if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0) {\n      return texts.join(\"\\n\\n\");\n    }\n  }\n  return null;\n}\nasync function arrayText(value, result = []) {\n  for await (const block of value) {\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      if (text !== null)\n        result.push(text);\n    } else if (block.isArray()) {\n      await arrayText(block, result);\n    }\n  }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type !== \"string\")\n    return null;\n  const children = obj.children;\n  if (!Array.isArray(children))\n    return null;\n  let result = \"\";\n  for (const child of children) {\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n      result += child.text;\n    }\n  }\n  return result;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n    case \"object\":\n      if (value._ref) {\n        return pathSet.has(value._ref);\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n  }\n  return false;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    if (code >= 55296 && code <= 56319) {\n      continue;\n    }\n    count2++;\n  }\n  return count2;\n}\nconst global = {};\nglobal.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\") {\n      return value;\n    }\n  }\n  return NULL_VALUE;\n};\nglobal.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray()) {\n    return NULL_VALUE;\n  }\n  let num = 0;\n  for await (const _ of inner) {\n    num++;\n  }\n  return fromNumber(num);\n};\nglobal.count.arity = 1;\nglobal.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  if (val.type === \"datetime\") {\n    return val;\n  }\n  if (val.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return DateTime.parseToValue(val.data);\n};\nglobal.dateTime.arity = 1;\nglobal.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\nglobal.defined.arity = 1;\nglobal.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity);\n};\nglobal.identity.arity = 0;\nglobal.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\") {\n    return fromNumber(countUTF8(inner.data));\n  }\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner) {\n      num++;\n    }\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\nglobal.length.arity = 1;\nglobal.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromPath(new Path(inner.data));\n};\nglobal.path.arity = 1;\nglobal.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(`${value.data}`);\n    default:\n      return NULL_VALUE;\n  }\n};\nglobal.string.arity = 1;\nglobal.references = async function references(args, scope, execute) {\n  const pathSet = new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\") {\n      pathSet.add(path2.data);\n    } else if (path2.isArray()) {\n      for await (const elem of path2) {\n        if (elem.type === \"string\") {\n          pathSet.add(elem.data);\n        }\n      }\n    }\n  }\n  if (pathSet.size === 0) {\n    return FALSE_VALUE;\n  }\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\nglobal.references.arity = (c) => c >= 1;\nglobal.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\") {\n    return NULL_VALUE;\n  }\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE;\n    }\n    prec = precValue.data;\n  }\n  if (prec === 0) {\n    if (num < 0) {\n      return fromNumber(-Math.round(-num));\n    }\n    return fromNumber(Math.round(num));\n  }\n  return fromNumber(Number(num.toFixed(prec)));\n};\nglobal.round.arity = (count2) => count2 >= 1 && count2 <= 2;\nglobal.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\nglobal.now.arity = 0;\nglobal.boost = async function boost() {\n  throw new Error(\"unexpected boost call\");\n};\nglobal.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nglobal.lower = string2.lower;\nglobal.upper = string2.upper;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  const text = await portableTextContent(value);\n  if (text === null) {\n    return NULL_VALUE;\n  }\n  return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId);\n  }\n  return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset);\n  }\n  return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n  await true;\n  if (!base.isArray()) {\n    return NULL_VALUE;\n  }\n  const mappers = [];\n  const directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    if (mapper.type === \"Desc\") {\n      direction = \"desc\";\n      mapper = mapper.base;\n    } else if (mapper.type === \"Asc\") {\n      mapper = mapper.base;\n    }\n    mappers.push(mapper);\n    directions.push(direction);\n    n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value);\n    const tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple);\n    idx++;\n  }\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\") {\n        c = -c;\n      }\n      if (c !== 0) {\n        return c;\n      }\n    }\n    return aTuple[1] - bTuple[1];\n  });\n  return fromJS(aux.map((v) => v[0]));\n};\npipeFunctions.order.arity = (count2) => count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray())\n    return NULL_VALUE;\n  const unknown = [];\n  const scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute);\n    }\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\n    scored.push(newObject);\n  }\n  scored.sort((a, b) => b._score - a._score);\n  return fromJS(scored);\n};\npipeFunctions.score.arity = (count2) => count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n  const hasBefore = scope.context.before !== null;\n  const hasAfter = scope.context.after !== null;\n  if (hasBefore && hasAfter) {\n    return fromString(\"update\");\n  }\n  if (hasAfter) {\n    return fromString(\"create\");\n  }\n  if (hasBefore) {\n    return fromString(\"delete\");\n  }\n  return NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst namespaces = {\n  global,\n  string: string2,\n  pt,\n  delta,\n  diff,\n  sanity\n};\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === \"error\")\n    return result;\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return { type: \"error\", position: pos };\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result;\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === \"error\")\n        return rhs;\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case \",\": {\n          marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === \"error\")\n              return rhs;\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== \",\")\n              break;\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== \")\")\n            return { type: \"error\", position: pos };\n          pos++;\n          marks.push({ name: \"tuple_end\", position: pos });\n          break;\n        }\n        case \")\": {\n          pos++;\n          marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n          break;\n        }\n        default:\n          return { type: \"error\", position: pos };\n      }\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"[\":\n      marks = [{ name: \"array\", position: pos }];\n      pos = skipWS(str, pos + 1);\n      if (str[pos] !== \"]\") {\n        while (true) {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            marks.push({ name: \"array_splat\", position: pos });\n            pos = skipWS(str, pos + 3);\n          }\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\")\n            return res;\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== \",\")\n            break;\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === \"]\")\n            break;\n        }\n      }\n      if (str[pos] === \"]\") {\n        pos++;\n        marks.push({ name: \"array_end\", position: pos });\n      } else {\n        return { type: \"error\", position: pos };\n      }\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"^\": {\n      pos++;\n      marks = [];\n      while (str[pos] === \".\" && str[pos + 1] === \"^\") {\n        marks.push({ name: \"dblparent\", position: startPos });\n        pos += 2;\n      }\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }];\n      pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }];\n      pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          { name: \"param\", position: startPos },\n          { name: \"ident\", position: startPos + 1 },\n          { name: \"ident_end\", position: pos }\n        ];\n      }\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = \"float\";\n            pos += 1 + fracLen;\n          }\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\";\n          pos++;\n          if (str[pos] === \"+\" || str[pos] === \"-\") {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen)\n            return { type: \"error\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\")\n              return result;\n            marks = result.marks;\n            pos = result.position;\n            break;\n          }\n          default: {\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n          }\n        }\n        break;\n      }\n    }\n  }\n  if (!marks) {\n    return { type: \"error\", position: pos };\n  }\n  let lhsLevel = 12;\n  let trav;\n  loop:\n    while (true) {\n      let innerPos = skipWS(str, pos);\n      if (innerPos === str.length) {\n        pos = innerPos;\n        break;\n      }\n      trav = parseTraversal(str, innerPos);\n      if (trav.type === \"success\") {\n        marks.unshift({ name: \"traverse\", position: startPos });\n        while (trav.type === \"success\") {\n          marks = marks.concat(trav.marks);\n          pos = trav.position;\n          trav = parseTraversal(str, skipWS(str, pos));\n        }\n        marks.push({ name: \"traversal_end\", position: pos });\n        continue;\n      }\n      let token2 = str[innerPos];\n      switch (token2) {\n        case \"=\": {\n          let nextToken = str[innerPos + 1];\n          switch (nextToken) {\n            case \">\": {\n              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks = marks.concat(rhs.marks);\n              marks.unshift({ name: \"pair\", position: startPos });\n              pos = rhs.position;\n              lhsLevel = PREC_PAIR;\n              break;\n            }\n            case \"=\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            default:\n              break loop;\n          }\n          break;\n        }\n        case \"+\": {\n          if (level > PREC_ADD || lhsLevel < PREC_ADD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"add\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_ADD;\n          break;\n        }\n        case \"-\": {\n          if (level > PREC_SUB || lhsLevel < PREC_SUB)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"sub\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_SUB;\n          break;\n        }\n        case \"*\": {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > PREC_POW || lhsLevel <= PREC_POW)\n              break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n            if (rhs2.type === \"error\")\n              return rhs2;\n            marks = marks.concat(rhs2.marks);\n            marks.unshift({ name: \"pow\", position: startPos });\n            pos = rhs2.position;\n            lhsLevel = PREC_POW;\n            break;\n          }\n          if (level > PREC_MUL || lhsLevel < PREC_MUL)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mul\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MUL;\n          break;\n        }\n        case \"/\": {\n          if (level > PREC_DIV || lhsLevel < PREC_DIV)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"div\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_DIV;\n          break;\n        }\n        case \"%\": {\n          if (level > PREC_MOD || lhsLevel < PREC_MOD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mod\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MOD;\n          break;\n        }\n        case \"<\":\n        case \">\": {\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n            break loop;\n          let nextPos = innerPos + 1;\n          if (str[nextPos] === \"=\") {\n            nextPos++;\n          }\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"|\": {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > PREC_OR || lhsLevel < PREC_OR)\n              break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n            if (rhs.type === \"error\")\n              return rhs;\n            marks = marks.concat(rhs.marks);\n            marks.unshift({ name: \"or\", position: startPos });\n            pos = rhs.position;\n            lhsLevel = PREC_OR;\n          } else {\n            if (level > 11 || lhsLevel < 11)\n              break loop;\n            let identPos = skipWS(str, innerPos + 1);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen)\n              return { type: \"error\", position: identPos };\n            pos = identPos + identLen;\n            if (str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\")\n                return result;\n              marks = marks.concat(result.marks);\n              marks.unshift({ name: \"pipecall\", position: startPos });\n              pos = result.position;\n              lhsLevel = 11;\n            }\n          }\n          break;\n        }\n        case \"&\": {\n          if (str[innerPos + 1] != \"&\")\n            break loop;\n          if (level > PREC_AND || lhsLevel < PREC_AND)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"and\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_AND;\n          break;\n        }\n        case \"!\": {\n          if (str[innerPos + 1] !== \"=\")\n            break loop;\n          if (level > PREC_COMP || lhsLevel < PREC_COMP)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"d\": {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"desc\", position: startPos });\n          pos = innerPos + 4;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        case \"a\": {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"asc\", position: startPos });\n          pos = innerPos + 3;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        default: {\n          let ident = parseRegexStr(str, innerPos, IDENT);\n          switch (ident) {\n            case \"in\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              pos = skipWS(str, innerPos + 2);\n              let isGroup = false;\n              if (str[pos] === \"(\") {\n                isGroup = true;\n                pos = skipWS(str, pos + 1);\n              }\n              let rangePos = pos;\n              let result = parseExpr(str, pos, PREC_COMP + 1);\n              if (result.type === \"error\")\n                return result;\n              pos = skipWS(str, result.position);\n              if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                let type = \"inc_range\";\n                if (str[pos + 2] === \".\") {\n                  type = \"exc_range\";\n                  pos = skipWS(str, pos + 3);\n                } else {\n                  pos = skipWS(str, pos + 2);\n                }\n                let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                if (rhs.type === \"error\")\n                  return rhs;\n                marks.unshift({ name: \"in_range\", position: startPos });\n                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);\n                pos = rhs.position;\n              } else {\n                marks.unshift({ name: \"comp\", position: startPos });\n                marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n                marks = marks.concat(result.marks);\n              }\n              if (isGroup) {\n                pos = skipWS(str, pos);\n                if (str[pos] !== \")\")\n                  return { type: \"error\", position: pos };\n                pos++;\n              }\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            case \"match\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = 4;\n              break;\n            }\n            default: {\n              break loop;\n            }\n          }\n        }\n      }\n    }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen2 = parseRegex(str, pos, IDENT);\n      if (!identLen2)\n        return { type: \"error\", position: pos };\n      pos += identLen2;\n      return {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push({ name: \"deref_attr\", position: identPos }, { name: \"ident\", position: identPos }, { name: \"ident_end\", position: pos });\n      }\n      return {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"]\") {\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      }\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      pos = skipWS(str, result.position);\n      if (str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        if (str[pos + 2] === \".\") {\n          type = \"exc_range\";\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === \"error\")\n          return rhs;\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== \"]\")\n          return { type: \"error\", position: pos };\n        return {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        };\n      }\n      if (str[pos] !== \"]\")\n        return { type: \"error\", position: pos };\n      return {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\")\n          return result;\n        result.marks.unshift({ name: \"projection\", position: startPos });\n        return result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      result.marks.unshift({ name: \"projection\", position: startPos });\n      return result;\n    }\n  }\n  return { type: \"error\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  marks.push({ name: \"func_call\", position: startPos });\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos });\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen)\n      return { type: \"error\", position: pos };\n    marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen });\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== \"(\")\n      return { type: \"error\", position: pos };\n    pos++;\n  } else {\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 1);\n  }\n  let lastPos = pos;\n  if (str[pos] !== \")\") {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== \",\")\n        break;\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \")\")\n        break;\n    }\n  }\n  if (str[pos] !== \")\") {\n    return { type: \"error\", position: pos };\n  }\n  marks.push({ name: \"func_args_end\", position: lastPos });\n  return {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  };\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  pos = skipWS(str, pos + 1);\n  while (str[pos] !== \"}\") {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\") {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\")\n          return expr;\n        marks.push({ name: \"object_splat\", position: pairPos });\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\")\n        return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\")\n          return value;\n        marks.push({ name: \"object_pair\", position: pairPos });\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== \",\")\n      break;\n    pos = skipWS(str, pos + 1);\n  }\n  if (str[pos] !== \"}\") {\n    return { type: \"error\", position: pos };\n  }\n  pos++;\n  marks.push({ name: \"object_end\", position: pos });\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str:\n    for (; ; pos++) {\n      if (pos > str.length)\n        return { type: \"error\", position: pos };\n      switch (str[pos]) {\n        case token: {\n          marks.push({ name: \"str_end\", position: pos });\n          pos++;\n          break str;\n        }\n        case \"\\\\\": {\n          marks.push({ name: \"str_pause\", position: pos });\n          if (str[pos + 1] === \"u\") {\n            if (str[pos + 2] === \"{\") {\n              marks.push({ name: \"unicode_hex\", position: pos + 3 });\n              pos = str.indexOf(\"}\", pos + 3);\n              marks.push({ name: \"unicode_hex_end\", position: pos });\n              pos++;\n            } else {\n              marks.push({ name: \"unicode_hex\", position: pos + 2 });\n              marks.push({ name: \"unicode_hex_end\", position: pos + 6 });\n              pos += 5;\n            }\n          } else {\n            marks.push({ name: \"single_escape\", position: pos + 1 });\n            pos += 1;\n          }\n          marks.push({ name: \"str_start\", position: pos + 1 });\n        }\n      }\n    }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right) {\n    return {\n      type: \"a-a\",\n      build\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right) {\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nconst isEqual = equality;\nfunction equality(a, b) {\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n    return a.data === b.data;\n  }\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\n    return a.data.equals(b.data);\n  }\n  return false;\n}\nconst operators = {\n  \"==\": function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function gt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function gte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function lt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function lte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  in: async function inop(left, right) {\n    if (right.type === \"path\") {\n      if (left.type !== \"string\") {\n        return NULL_VALUE;\n      }\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    }\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE;\n        }\n      }\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function match(left, right) {\n    let tokens = [];\n    let patterns = [];\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    });\n    if (!didSucceed) {\n      return FALSE_VALUE;\n    }\n    const matched = matchText(tokens, patterns);\n    return matched ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function plus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data + right.data);\n    }\n    if (left.type === \"string\" && right.type === \"string\") {\n      return fromString(left.data + right.data);\n    }\n    if (left.type === \"object\" && right.type === \"object\") {\n      return fromJS(__spreadValues(__spreadValues({}, left.data), right.data));\n    }\n    if (left.type === \"array\" && right.type === \"array\") {\n      return fromJS(left.data.concat(right.data));\n    }\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val;\n        }\n        for await (const val of right) {\n          yield val;\n        }\n      });\n    }\n    return NULL_VALUE;\n  },\n  \"-\": function minus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(-right.data));\n    }\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\n      return fromNumber(left.data.difference(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data - right.data);\n    }\n    return NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nclass Scope {\n  constructor(params, source, value, context, parent) {\n    this.isHidden = false;\n    this.params = params;\n    this.source = source;\n    this.value = value;\n    this.context = context;\n    this.parent = parent;\n  }\n  createNested(value) {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent);\n    }\n    return new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    result.isHidden = true;\n    return result;\n  }\n}\nfunction evaluate(node, scope, execute = evaluate) {\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  if (\"then\" in value) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter({ name }, scope) {\n    return fromJS(scope.params[name]);\n  },\n  Context({ key }, scope) {\n    if (key === \"before\" || key === \"after\") {\n      const value = scope.context[key];\n      return value || NULL_VALUE;\n    }\n    throw new Error(`unknown context key: ${key}`);\n  },\n  Parent({ n }, scope) {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE;\n      }\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall({ op, left, right }, scope, execute) {\n    const func = operators[op];\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`);\n    }\n    const leftValue = execute(left, scope);\n    const rightValue = execute(right, scope);\n    if (\"then\" in leftValue || \"then\" in rightValue) {\n      return (async () => func(await leftValue, await rightValue))();\n    }\n    return func(leftValue, rightValue);\n  },\n  async Select({ alternatives, fallback }, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === true) {\n        return execute(alt.value, scope);\n      }\n    }\n    if (fallback) {\n      return execute(fallback, scope);\n    }\n    return NULL_VALUE;\n  },\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\n    const value = await execute(base, scope);\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null) {\n      return NULL_VALUE;\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    if (rightCmp === null) {\n      return NULL_VALUE;\n    }\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem);\n        const exprValue = await execute(expr, newScope);\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\n          yield elem;\n        }\n      }\n    });\n  },\n  async Projection({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall({ func, args }, scope, execute) {\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall({ func, base, args }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute({ base, name }, scope, execute) {\n    let value = scope.value;\n    if (base) {\n      value = await execute(base, scope);\n    }\n    if (value.type === \"object\") {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name]);\n      }\n    }\n    return NULL_VALUE;\n  },\n  async AccessElement({ base, index }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const data = await baseValue.get();\n    const finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const array = await baseValue.get();\n    let leftIdx = left;\n    let rightIdx = right;\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx;\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx;\n    }\n    if (isInclusive) {\n      rightIdx++;\n    }\n    if (leftIdx < 0) {\n      leftIdx = 0;\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0;\n    }\n    return fromJS(array.slice(leftIdx, rightIdx));\n  },\n  async Deref({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!scope.source.isArray()) {\n      return NULL_VALUE;\n    }\n    if (value.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const id = value.data._ref;\n    if (typeof id !== \"string\") {\n      return NULL_VALUE;\n    }\n    for await (const doc of scope.source) {\n      if (doc.type === \"object\" && id === doc.data._id) {\n        return doc;\n      }\n    }\n    return NULL_VALUE;\n  },\n  Value({ value }) {\n    return fromJS(value);\n  },\n  Group({ base }, scope, execute) {\n    return execute(base, scope);\n  },\n  async Object({ attributes }, scope, execute) {\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\": {\n          const value = await execute(attr.value, scope);\n          result[attr.name] = await value.get();\n          break;\n        }\n        case \"ObjectConditionalSplat\": {\n          const cond = await execute(attr.condition, scope);\n          if (cond.type !== \"boolean\" || cond.data === false) {\n            continue;\n          }\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        case \"ObjectSplat\": {\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${attrType}`);\n      }\n    }\n    return fromJS(result);\n  },\n  Array({ elements }, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v;\n            }\n          }\n        } else {\n          yield value;\n        }\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return FALSE_VALUE;\n  },\n  async And({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return TRUE_VALUE;\n  },\n  async Not({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (value.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(-value.data);\n    });\n  },\n  Pos({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(value.data);\n    });\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    });\n  },\n  async FlatMap({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        const innerValue = await execute(expr, newScope);\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner;\n          }\n        } else {\n          yield innerValue;\n        }\n      }\n    });\n  }\n};\nfunction evaluateQuery(tree, options = {}) {\n  const root = fromJS(options.root);\n  const dataset = fromJS(options.dataset);\n  const params = __spreadValues({}, options.params);\n  const scope = new Scope(params, dataset, root, {\n    timestamp: options.timestamp || new Date(),\n    identity: options.identity === void 0 ? \"me\" : options.identity,\n    sanity: options.sanity,\n    after: options.after ? fromJS(options.after) : null,\n    before: options.before ? fromJS(options.before) : null\n  }, null);\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n    case \"Value\":\n    case \"Parameter\":\n    case \"Pos\":\n    case \"Neg\":\n      return true;\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return true;\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: \"me\", before: null, after: null }, null);\nclass ConstantEvaluateError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConstantEvaluateError\";\n  }\n}\nfunction tryConstantEvaluate(node) {\n  try {\n    return constantEvaluate(node);\n  } catch (err) {\n    if (err.name === \"ConstantEvaluateError\") {\n      return null;\n    }\n    throw err;\n  }\n}\nfunction constantEvaluate(node) {\n  if (!canConstantEvaluate(node)) {\n    throw new ConstantEvaluateError(\"cannot constant evaluate\");\n  }\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value) {\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  }\n  return value;\n}\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"GroqQueryError\";\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER);\n    return {\n      type: \"Group\",\n      base: inner\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER);\n    return {\n      type: \"Parent\",\n      n: next.n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER);\n    const traversalList = [];\n    while (p.getMark().name !== \"traversal_end\") {\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    }\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal);\n    }\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n      traversal = traverseArray((val) => val, traversal);\n    }\n    if (traversal === null)\n      throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    if (name === \"null\") {\n      return { type: \"Value\", value: null };\n    }\n    if (name === \"true\") {\n      return { type: \"Value\", value: true };\n    }\n    if (name === \"false\") {\n      return { type: \"Value\", value: false };\n    }\n    return {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Neg\",\n      base\n    };\n  },\n  pos(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Pos\",\n      base\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER);\n    const op = p.processString();\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER);\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop:\n      while (p.hasMark()) {\n        const mark = p.getMark();\n        switch (mark.name) {\n          case \"str_end\":\n            value += p.processStringEnd();\n            break loop;\n          case \"str_pause\":\n            value += p.processStringEnd();\n            break;\n          case \"str_start\":\n            p.shift();\n            break;\n          case \"single_escape\": {\n            const char = p.slice(1);\n            p.shift();\n            value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n          case \"unicode_hex\":\n            p.shift();\n            value += expandHex(p.processStringEnd());\n            break;\n          default:\n            throw new Error(`unexpected mark: ${mark.name}`);\n        }\n      }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    while (p.getMark().name !== \"object_end\") {\n      attributes.push(p.process(OBJECT_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    while (p.getMark().name !== \"array_end\") {\n      let isSplat = false;\n      if (p.getMark().name === \"array_splat\") {\n        isSplat = true;\n        p.shift();\n      }\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    p.shift();\n    return {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    while (p.getMark().name !== \"tuple_end\") {\n      members.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      while (p.getMark().name !== \"func_args_end\") {\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback)\n            throw new GroqQueryError(`unexpected argument to select()`);\n          p.shift();\n          const condition = p.process(EXPR_BUILDER);\n          const value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback)\n            throw new GroqQueryError(`unexpected argument to select()`);\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      }\n      p.shift();\n      return result;\n    }\n    const args = [];\n    while (p.getMark().name !== \"func_args_end\") {\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n      if (p.parseOptions.mode === \"delta\") {\n        return {\n          type: \"Context\",\n          key: name\n        };\n      }\n    }\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    }\n    const func = funcs[name];\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    }\n    if (func.arity !== void 0) {\n      validateArity(name, func.arity, args.length);\n    }\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    }\n    return {\n      type: \"FuncCall\",\n      func,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    if (namespace !== \"global\") {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    }\n    const name = p.processString();\n    const args = [];\n    const oldAllowBoost = p.allowBoost;\n    if (name === \"score\") {\n      p.allowBoost = true;\n    }\n    for (; ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\") {\n        break;\n      }\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift();\n          args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift();\n          args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length);\n    }\n    return {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`);\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Not\",\n      base\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      };\n    }\n    return {\n      type: \"Parameter\",\n      name\n    };\n  }\n};\nconst OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER);\n      const value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\")\n      throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectSplat\",\n      value\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n};\nconst TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER);\n    const value = tryConstantEvaluate(expr);\n    if (value && value.type === \"number\") {\n      return (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right);\n    }\n    if (value && value.type === \"string\") {\n      return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right);\n    }\n    return (right) => traverseArray((base) => ({\n      type: \"Filter\",\n      base,\n      expr\n    }), right);\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    const leftValue = tryConstantEvaluate(left);\n    const rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    }\n    return (rhs) => traverseArray((base) => ({\n      type: \"Slice\",\n      base,\n      left: leftValue.data,\n      right: rightValue.data,\n      isInclusive\n    }), rhs);\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    if (p.getMark().name === \"deref_attr\") {\n      p.shift();\n      attr = p.processString();\n    }\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain((base) => wrap({\n      type: \"Deref\",\n      base\n    }), right);\n  },\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base) {\n    return node.name;\n  }\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n    return extractPropertyKey(node.base);\n  }\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count2) {\n  if (typeof arity === \"number\") {\n    if (count2 !== arity) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count2}.`);\n    }\n  } else if (arity) {\n    if (!arity(count2)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n    }\n  }\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(`Syntax error in GROQ query at position ${position}`);\n    this.name = \"GroqSyntaxError\";\n    this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\") {\n    throw new GroqSyntaxError(result.position);\n  }\n  const processor = new MarkProcessor(input, result.marks, options);\n  return processor.process(EXPR_BUILDER);\n}\n\n//# sourceMappingURL=groq-js.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC9ncm9xLWpzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBLFlBQVksS0FBSyxHQUFHLE1BQU0sR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHLE9BQU8sR0FBRyxPQUFPLEVBQUUsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QyxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0Isb0JBQW9CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsTUFBTTtBQUNwQjtBQUNBLEdBQUc7QUFDSCxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRCxHQUFHO0FBQ0gsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsR0FBRztBQUNILHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLE9BQU87QUFDakI7QUFDQSxHQUFHO0FBQ0gsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsR0FBRztBQUNILGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCLG1FQUFtRTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLLGVBQWUsTUFBTSxRQUFRLE9BQU87QUFDckg7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvZ3JvcS1qcy5lc20uanM/N2UyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nMywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgIHRoaXMuYWxsb3dCb29zdCA9IGZhbHNlO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nMztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcbiAgfVxuICBnZXRNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrc1t0aGlzLmluZGV4ICsgcG9zXTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gIH1cbiAgcHJvY2Vzcyh2aXNpdG9yKSB7XG4gICAgY29uc3QgbWFyayA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB2aXNpdG9yW21hcmsubmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZygpIHtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gIH1cbiAgc2xpY2UobGVuKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICB9XG59XG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICBpZiAoUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICBjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KTtcbiAgY29uc3QgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKTtcbiAgY29uc3QgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpO1xuICBjb25zdCBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKTtcbiAgY29uc3QgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpO1xuICBjb25zdCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gIGxldCBmcmFjdGlvbmFsU2Vjb25kID0gXCJcIjtcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgZnJhY3Rpb25hbFNlY29uZCA9IGAuJHthZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpfWA7XG4gIH1cbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0ke2ZyYWN0aW9uYWxTZWNvbmR9WmA7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgc3RyID0gYDAke3N0cn1gO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nMykge1xuICByZXR1cm4gc3RyaW5nMy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiBwYXRoUmVnRXhwKHBhdHRlcm4pIHtcbiAgY29uc3QgcmUgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4uc3BsaXQoXCIuXCIpKSB7XG4gICAgaWYgKHBhcnQgPT09IFwiKlwiKSB7XG4gICAgICByZS5wdXNoKFwiW14uXStcIik7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIioqXCIpIHtcbiAgICAgIHJlLnB1c2goXCIuKlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmUucHVzaChlc2NhcGVSZWdFeHAocGFydCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmUuam9pbihcIi5cIil9JGApO1xufVxuY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuICBtYXRjaGVzKHN0cikge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cbn1cbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy50eXBlID0gXCJzdHJlYW1cIjtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICB0aGlzLnRpY2tlciA9IG51bGw7XG4gICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGdldCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9uZXh0VGljaygpO1xuICAgIH1cbiAgfVxuICBfbmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMudGlja2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgfVxuICAgIGxldCBjdXJyZW50UmVzb2x2ZXI7XG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNsYXNzIFN0YXRpY1ZhbHVlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIik7XG5jb25zdCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKHRydWUsIFwiYm9vbGVhblwiKTtcbmNvbnN0IEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKGZhbHNlLCBcImJvb2xlYW5cIik7XG5jbGFzcyBEYXRlVGltZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIGlmIChkYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoMikge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgyLCBcInBhdGhcIik7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZnJvbUpTKHZhbCkge1xuICBpZiAoaXNJdGVyYXRvcih2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB2YWwpIHtcbiAgICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgZ2V0VHlwZSh2YWwpKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgcmV0dXJuIFwicGF0aFwiO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gXCJkYXRldGltZVwiO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZGF0YTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgaWYgKGEgPCBiKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoYSA+IGIpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgY29uc3QgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcbiAgY29uc3QgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpIHtcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xuY29uc3QgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xuY29uc3QgTUFYX1RFUk1fTEVOR1RIID0gMTAyNDtcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcbiAgY29uc3QgdGVybXNSZSA9IG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpO1xuICByZXR1cm4gdGVybXNSZS5tYXAoKHJlKSA9PiAodG9rZW5zKSA9PiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHJlLnRlc3QodG9rZW4pKSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KSB7XG4gIGNvbnN0IHRlcm1zID0gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdO1xuICByZXR1cm4gdGVybXMubWFwKCh0ZXJtKSA9PiBuZXcgUmVnRXhwKGBeJHt0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKSk7XG59XG5hc3luYyBmdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBjYikge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNiKHZhbHVlLmRhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHZhbHVlKSB7XG4gICAgICBpZiAocGFydC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNiKHBhcnQuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IEJNMjVrID0gMS4yO1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIikge1xuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmUobm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgYm9vc3QyID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QyLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDApIHtcbiAgICAgIHJldHVybiBpbm5lclNjb3JlICsgYm9vc3QyLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9yXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgaWYgKGxlZnRTY29yZSA9PT0gMCB8fCByaWdodFNjb3JlID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiByZXMudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzLmRhdGEgPT09IHRydWUgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZShsZWZ0LCByaWdodCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICBjb25zdCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCB0ZXJtcyA9IFtdO1xuICBhd2FpdCBnYXRoZXJUZXh0KHRleHQsIChwYXJ0KSA9PiB7XG4gICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgfSk7XG4gIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHBhdHRlcm4sIChwYXJ0KSA9PiB7XG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICB9KTtcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHNjb3JlMiA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcbiAgICBjb25zdCBmcmVxID0gdG9rZW5zLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgIHNjb3JlMiArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmUyO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBibG9ja1RleHQodmFsdWUuZGF0YSk7XG4gIH0gZWxzZSBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGV4dHMuam9pbihcIlxcblxcblwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgdmFsdWUpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIGlmICh0ZXh0ICE9PSBudWxsKVxuICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGJsb2NrLmlzQXJyYXkoKSkge1xuICAgICAgYXdhaXQgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY2hpbGQuX3R5cGUgPT09IFwic3RyaW5nXCIgJiYgY2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIHR5cGVvZiBjaGlsZC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAodmFsdWUuX3JlZikge1xuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudDIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY291bnQyKys7XG4gIH1cbiAgcmV0dXJuIGNvdW50Mjtcbn1cbmNvbnN0IGdsb2JhbCA9IHt9O1xuZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbnVtID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKSB7XG4gICAgbnVtKys7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbn07XG5nbG9iYWwuY291bnQuYXJpdHkgPSAxO1xuZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuZ2xvYmFsLmRlZmluZWQgPSBhc3luYyBmdW5jdGlvbiBkZWZpbmVkKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBpbm5lci50eXBlID09PSBcIm51bGxcIiA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbn07XG5nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbiBpZGVudGl0eShhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KTtcbn07XG5nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5nbG9iYWwucGF0aCA9IGFzeW5jIGZ1bmN0aW9uIHBhdGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpO1xufTtcbmdsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbmdsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbmdsb2JhbC5yZWZlcmVuY2VzID0gYXN5bmMgZnVuY3Rpb24gcmVmZXJlbmNlcyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBwYXRoU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgcGF0aDIgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXRoU2V0LmFkZChwYXRoMi5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHBhdGgyLmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKSB7XG4gICAgICAgIGlmIChlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBwYXRoU2V0LmFkZChlbGVtLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xuICByZXR1cm4gaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbmdsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gKGMpID0+IGMgPj0gMTtcbmdsb2JhbC5yb3VuZCA9IGFzeW5jIGZ1bmN0aW9uIHJvdW5kKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcbiAgbGV0IHByZWMgPSAwO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwcmVjVmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAocHJlY1ZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgfVxuICBpZiAocHJlYyA9PT0gMCkge1xuICAgIGlmIChudW0gPCAwKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XG59O1xuZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5nbG9iYWwubm93ID0gYXN5bmMgZnVuY3Rpb24gbm93KGFyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpO1xufTtcbmdsb2JhbC5ub3cuYXJpdHkgPSAwO1xuZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24gYm9vc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xuY29uc3Qgc3RyaW5nMiA9IHt9O1xuc3RyaW5nMi5sb3dlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSk7XG59O1xuc3RyaW5nMi51cHBlci5hcml0eSA9IDE7XG5nbG9iYWwubG93ZXIgPSBzdHJpbmcyLmxvd2VyO1xuZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHRleHQpO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3Qgc2FuaXR5ID0ge307XG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBhd2FpdCB0cnVlO1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbWFwcGVycyA9IFtdO1xuICBjb25zdCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBpZiAobWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiKSB7XG4gICAgICBkaXJlY3Rpb24gPSBcImRlc2NcIjtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH0gZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09IFwiQXNjXCIpIHtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH1cbiAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICBuKys7XG4gIH1cbiAgY29uc3QgYXV4ID0gW107XG4gIGxldCBpZHggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgY29uc3QgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSk7XG4gICAgaWR4Kys7XG4gIH1cbiAgYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiKSB7XG4gICAgICAgIGMgPSAtYztcbiAgICAgIH1cbiAgICAgIGlmIChjICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KTtcbiAgcmV0dXJuIGZyb21KUyhhdXgubWFwKCh2KSA9PiB2WzBdKSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXTtcbiAgY29uc3Qgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHsgX3Njb3JlOiB2YWx1ZVNjb3JlIH0pO1xuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gIH1cbiAgc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpO1xuICByZXR1cm4gZnJvbUpTKHNjb3JlZCk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbCxcbiAgc3RyaW5nOiBzdHJpbmcyLFxuICBwdCxcbiAgZGVsdGEsXG4gIGRpZmYsXG4gIHNhbml0eVxufTtcbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xuY29uc3QgTlVNID0gL15cXGQrLztcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcbmNvbnN0IFBSRUNfUEFJUiA9IDE7XG5jb25zdCBQUkVDX09SID0gMjtcbmNvbnN0IFBSRUNfQU5EID0gMztcbmNvbnN0IFBSRUNfQ09NUCA9IDQ7XG5jb25zdCBQUkVDX09SREVSID0gNDtcbmNvbnN0IFBSRUNfQUREID0gNjtcbmNvbnN0IFBSRUNfU1VCID0gNjtcbmNvbnN0IFBSRUNfTVVMID0gNztcbmNvbnN0IFBSRUNfRElWID0gNztcbmNvbnN0IFBSRUNfTU9EID0gNztcbmNvbnN0IFBSRUNfUE9XID0gODtcbmNvbnN0IFBSRUNfUE9TID0gMTA7XG5jb25zdCBQUkVDX05PVCA9IDEwO1xuY29uc3QgUFJFQ19ORUcgPSA4O1xuZnVuY3Rpb24gcGFyc2UkMShzdHIpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgbGV0IG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX1BPUyk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibmVnXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInR1cGxlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0dXBsZV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiKVwiOiB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19OT1QpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImFycmF5XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmVzLnBvc2l0aW9uO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiXlwiOiB7XG4gICAgICBwb3MrKztcbiAgICAgIG1hcmtzID0gW107XG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIkXCI6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImZsb2F0XCI7XG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XG4gICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgY2FzZSBcIihcIjoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aGlzX2F0dHJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuICBsb29wOlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcbiAgICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSB0cmF2LnBvc2l0aW9uO1xuICAgICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICAgIHN3aXRjaCAodG9rZW4yKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICBsZXQgbmV4dFRva2VuID0gc3RyW2lubmVyUG9zICsgMV07XG4gICAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QQUlSIHx8IGxoc0xldmVsIDw9IFBSRUNfUEFJUilcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BBSVI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIitcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUE9XIHx8IGxoc0xldmVsIDw9IFBSRUNfUE9XKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJoczIgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHMyO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgcG9zID0gcmhzMi5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QT1c7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NVUwgfHwgbGhzTGV2ZWwgPCBQUkVDX01VTClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19ESVYgfHwgbGhzTGV2ZWwgPCBQUkVDX0RJVilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJVwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NT0QgfHwgbGhzTGV2ZWwgPCBQUkVDX01PRClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IG5leHRQb3MgPSBpbm5lclBvcyArIDE7XG4gICAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIG5leHRQb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1IgfHwgbGhzTGV2ZWwgPCBQUkVDX09SKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfT1IgKyAxKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSlcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0FORCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BTkQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiFcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8IFBSRUNfQ09NUClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkXCI6IHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDQpICE9PSBcImRlc2NcIilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgNDtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGxldCBpZGVudCA9IHBhcnNlUmVnZXhTdHIoc3RyLCBpbm5lclBvcywgSURFTlQpO1xuICAgICAgICAgIHN3aXRjaCAoaWRlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcbiAgICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJpbl9yYW5nZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSk7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSAodHJhdiA9PSBudWxsID8gdm9pZCAwIDogdHJhdi50eXBlKSA9PT0gXCJlcnJvclwiICYmIHRyYXYucG9zaXRpb247XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgbGV0IGlkZW50TGVuMiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmICghaWRlbnRMZW4yKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIHBvcyArPSBpZGVudExlbjI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7IG5hbWU6IFwiYXR0cl9hY2Nlc3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXSxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09IFwiPlwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSwgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcbiAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2NhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBwb3MrKztcbiAgfSBlbHNlIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIilcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIHBvcysrO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOlxuICAgIGZvciAoOyA7IHBvcysrKSB7XG4gICAgICBpZiAocG9zID4gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgYnJlYWsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSBcInVcIikge1xuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KTtcbiAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiTWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJGbGF0TWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICBidWlsZFxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5jb25zdCBpc0VxdWFsID0gZXF1YWxpdHk7XG5mdW5jdGlvbiBlcXVhbGl0eShhLCBiKSB7XG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgfVxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgXCI9PVwiOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIhPVwiOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uIGx0KGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPD1cIjogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBpbjogYXN5bmMgZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIikge1xuICAgICAgaWYgKGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KSB7XG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGIpKSB7XG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcGF0dGVybnMgPSBbXTtcbiAgICBhd2FpdCBnYXRoZXJUZXh0KGxlZnQsIChwYXJ0KSA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCAocGFydCkgPT4ge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgfSk7XG4gICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgcmV0dXJuIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgbGVmdC5kYXRhKSwgcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfTtcbn1cbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmVzdWx0LmlzSGlkZGVuID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSA9IGV2YWx1YXRlKSB7XG4gIGNvbnN0IGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRoZW4oY2IpO1xuICB9XG4gIHJldHVybiBjYih2YWx1ZSk7XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXMoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoeyBuYW1lIH0sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xuICB9LFxuICBDb250ZXh0KHsga2V5IH0sIHNjb3BlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgY29uc3QgdmFsdWUgPSBzY29wZS5jb250ZXh0W2tleV07XG4gICAgICByZXR1cm4gdmFsdWUgfHwgTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcbiAgfSxcbiAgUGFyZW50KHsgbiB9LCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcH1gKTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAoXCJ0aGVuXCIgaW4gbGVmdFZhbHVlIHx8IFwidGhlblwiIGluIHJpZ2h0VmFsdWUpIHtcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gZnVuYyhhd2FpdCBsZWZ0VmFsdWUsIGF3YWl0IHJpZ2h0VmFsdWUpKSgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICB9LFxuICBhc3luYyBTZWxlY3QoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKTtcbiAgICAgICAgY29uc3QgZXhwclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAodmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzRWxlbWVudCh7IGJhc2UsIGluZGV4IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoeyB2YWx1ZSB9KSB7XG4gICAgcmV0dXJuIGZyb21KUyh2YWx1ZSk7XG4gIH0sXG4gIEdyb3VwKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgfSxcbiAgYXN5bmMgT2JqZWN0KHsgYXR0cmlidXRlcyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZShhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7YXR0clR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoeyBlbGVtZW50cyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICBpZiAoZWxlbWVudC5pc1NwbGF0KSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIFR1cGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR1cGxlcyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSxcbiAgYXN5bmMgT3IoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBOb3QoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgTmVnKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xuICAgIH0pO1xuICB9LFxuICBQb3MoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgQXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBEZXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBcnJheUNvZXJjZSh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgY29uc3QgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICBjb25zdCBwYXJhbXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICBjb25zdCBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcbiAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IG5ldyBEYXRlKCksXG4gICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcbiAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsXG4gIH0sIG51bGwpO1xuICByZXR1cm4gZXZhbHVhdGUodHJlZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSwgbnVsbCk7XG5jbGFzcyBDb25zdGFudEV2YWx1YXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5uYW1lID0gXCJDb25zdGFudEV2YWx1YXRlRXJyb3JcIjtcbiAgfVxufVxuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbnN0YW50RXZhbHVhdGUobm9kZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJDb25zdGFudEV2YWx1YXRlRXJyb3JcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGlmICghY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSkge1xuICAgIHRocm93IG5ldyBDb25zdGFudEV2YWx1YXRlRXJyb3IoXCJjYW5ub3QgY29uc3RhbnQgZXZhbHVhdGVcIik7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShub2RlLCBEVU1NWV9TQ09QRSwgY29uc3RhbnRFdmFsdWF0ZSk7XG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogY29uc3RhbnQgZXZhbHVhdGUgc2hvdWxkIG5ldmVyIHJldHVybiBhIHByb21pc2VcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBcIlxcblwiLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubmFtZSA9IFwiR3JvcVF1ZXJ5RXJyb3JcIjtcbiAgfVxufVxuY29uc3QgRVhQUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgY29uc3QgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgYmFzZTogaW5uZXJcbiAgICB9O1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogMVxuICAgIH07XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgY29uc3QgbmV4dCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogbmV4dC5uICsgMVxuICAgIH07XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgdHJhdmVyc2FsID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNlQXJyYXkoKHZhbCkgPT4gdmFsLCB0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIioqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBjb21wKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3Qgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6XG4gICAgICB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgICAgY29uc3QgbWFyayA9IHAuZ2V0TWFyaygpO1xuICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcms6ICR7bWFyay5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiKSB7XG4gICAgICBsZXQgaXNTcGxhdCA9IGZhbHNlO1xuICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiYXJyYXlfc3BsYXRcIikge1xuICAgICAgICBpc1NwbGF0ID0gdHJ1ZTtcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIkFycmF5RWxlbWVudFwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNTcGxhdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgZWxlbWVudHNcbiAgICB9O1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiKSB7XG4gICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVHVwbGVcIixcbiAgICAgIG1lbWJlcnNcbiAgICB9O1xuICB9LFxuICBmdW5jX2NhbGwocCkge1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYHVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClgKTtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGB1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpYCk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xuICAgICAgaWYgKHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgIGlmIChuYW1lID09PSBcInNjb3JlXCIpIHtcbiAgICAgIHAuYWxsb3dCb29zdCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCA9PmApO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXG4gICAgICBiYXNlLFxuICAgICAgZXhwclxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIHNsaWNlKHApIHtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwic2xpY2luZyBtdXN0IHVzZSBjb25zdGFudCBudW1iZXJzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0pLCByaHMpO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVByb2plY3Rpb24oKGJhc2UpID0+ICh7IHR5cGU6IFwiUHJvamVjdGlvblwiLCBiYXNlLCBleHByOiBvYmogfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXAgPSAoYmFzZSkgPT4gYXR0ciA/IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiB3cmFwKHtcbiAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgIGJhc2VcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBhcnJheV9wb3N0Zml4KHApIHtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSkge1xuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJEZXJlZlwiIHx8IG5vZGUudHlwZSA9PT0gXCJNYXBcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJvamVjdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTbGljZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJGaWx0ZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQWNjZXNzRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB9XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQyKSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnQyICE9PSBhcml0eSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudDJ9LmApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcml0eSkge1xuICAgIGlmICghYXJpdHkoY291bnQyKSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHcm9xU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uKSB7XG4gICAgc3VwZXIoYFN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uICR7cG9zaXRpb259YCk7XG4gICAgdGhpcy5uYW1lID0gXCJHcm9xU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpO1xuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmV4cG9ydCB7IGV2YWx1YXRlUXVlcnkgYXMgZXZhbHVhdGUsIHBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLWpzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/groq-js/dist/groq-js.esm.js\n");

/***/ }),

/***/ "../node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!**************************************************************!*\
  !*** ../node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"../node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"../node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = /** @class */ (function () {\n    function Model(meta) {\n        this.meta = meta;\n    }\n    Model.prototype.wrap = function (data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    };\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\n        if (endMeta === void 0) { endMeta = this.meta; }\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\n    };\n    Model.prototype.asObject = function (value) {\n        if (!value.content) {\n            var fields = {};\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = { type: 'object', fields: fields };\n        }\n        return value.content;\n    };\n    Model.prototype.asArray = function (value) {\n        var _this = this;\n        if (!value.content) {\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\n            var metas = elements.map(function () { return _this.meta; });\n            value.content = { type: 'array', elements: elements, metas: metas };\n        }\n        return value.content;\n    };\n    Model.prototype.asString = function (value) {\n        if (!value.content) {\n            var str = value.data;\n            var part = {\n                value: str,\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([part]);\n        }\n        return value.content;\n    };\n    Model.prototype.stringFromParts = function (parts) {\n        var str = {\n            type: 'string',\n            parts: parts\n        };\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            part.uses.push(str);\n        }\n        return str;\n    };\n    Model.prototype.objectGetKeys = function (value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        }\n        else {\n            return Object.keys(value.data);\n        }\n    };\n    Model.prototype.objectGetField = function (value, key) {\n        var obj = this.asObject(value);\n        return obj.fields[key];\n    };\n    Model.prototype.arrayGetElement = function (value, idx) {\n        var arr = this.asArray(value);\n        return arr.elements[idx];\n    };\n    Model.prototype.finalize = function (content) {\n        this.updateEndMeta(content);\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\n    };\n    Model.prototype.markChanged = function (value) {\n        return this.wrap(unwrap(value));\n    };\n    Model.prototype.updateEndMeta = function (content) {\n        if (content.type == 'string') {\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\n                var part = _a[_i];\n                part.endMeta = this.meta;\n            }\n        }\n        else {\n            if (content.type === 'array') {\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\n                    var val = _c[_b];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n            else {\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\n                    var val = _e[_d];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    };\n    Model.prototype.copyString = function (value) {\n        if (value) {\n            var other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        }\n        else {\n            return {\n                type: 'string',\n                parts: []\n            };\n        }\n    };\n    Model.prototype.copyObject = function (value) {\n        var obj = {\n            type: 'object',\n            fields: {}\n        };\n        if (value) {\n            var other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    };\n    Model.prototype.copyArray = function (value) {\n        var arr = value ? this.asArray(value) : null;\n        var elements = arr ? arr.elements : [];\n        var metas = arr ? arr.metas : [];\n        return {\n            type: 'array',\n            elements: elements,\n            metas: metas\n        };\n    };\n    Model.prototype.objectSetField = function (target, key, value) {\n        target.fields[key] = value;\n    };\n    Model.prototype.objectDeleteField = function (target, key) {\n        delete target.fields[key];\n    };\n    Model.prototype.arrayAppendValue = function (target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    };\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\n        var _a, _b;\n        var arr = this.asArray(source);\n        var samePosition = arr.elements.length === left;\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\n        if (samePosition) {\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\n        }\n        else {\n            for (var i = left; i < right; i++) {\n                target.metas.push(this.meta);\n            }\n        }\n    };\n    Model.prototype.stringAppendValue = function (target, value) {\n        var str = this.asString(value);\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    Model.prototype.stringAppendPart = function (target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    };\n    Model.prototype.resolveStringPart = function (str, from, len) {\n        if (len === 0)\n            return from;\n        for (var i = from; i < str.parts.length; i++) {\n            var part = str.parts[i];\n            if (len === part.utf8size) {\n                // Matches perfect!\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                // It's a part of this chunk. We now need to split it up.\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error('splitting string out of bounds');\n    };\n    Model.prototype.splitString = function (part, idx) {\n        var leftValue;\n        var rightValue;\n        var leftSize = idx;\n        var rightSize = part.utf8size - leftSize;\n        // idx is here in UTF-8 index, not codepoint index.\n        // This means we might to adjust for multi-byte characters.\n        if (part.utf8size !== part.value.length) {\n            var byteCount = 0;\n            for (idx = 0; byteCount < leftSize; idx++) {\n                var code = part.value.codePointAt(idx);\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\n                if (size === 4)\n                    idx++; // Surrogate pair.\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        var newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\n            var use = _a[_i];\n            // Insert the new part.\n            var idx_1 = use.parts.indexOf(part);\n            if (idx_1 === -1)\n                throw new Error('bug: mismatch between string parts and use.');\n            use.parts.splice(idx_1 + 1, 0, newPart);\n        }\n    };\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\n        var str = this.asString(source);\n        var firstPart = this.resolveStringPart(str, 0, left);\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for (var i = firstPart; i < lastPart; i++) {\n            var part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    return Model;\n}());\n// Turns a native JavaScript object into a Value with a given origin.\nfunction wrap(data, meta) {\n    return { data: data, startMeta: meta, endMeta: meta };\n}\n// Converts a Value into a native JavaScript type.\nfunction unwrap(value) {\n    if (typeof value.data !== 'undefined')\n        return value.data;\n    var result;\n    var content = value.content;\n    switch (content.type) {\n        case 'string':\n            result = content.parts.map(function (part) { return part.value; }).join('');\n            break;\n        case 'array':\n            result = content.elements.map(function (val) { return unwrap(val); });\n            break;\n        case 'object': {\n            result = {};\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                result[key] = unwrap(val);\n            }\n        }\n    }\n    value.data = result;\n    return result;\n}\n// Returns the type of a Value.\nfunction getType(value) {\n    if (value.content)\n        return value.content.type;\n    if (Array.isArray(value.data))\n        return 'array';\n    if (value.data === null)\n        return 'null';\n    return typeof value.data;\n}\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nfunction rebaseValue(left, right) {\n    var leftType = getType(left);\n    var rightType = getType(right);\n    if (leftType !== rightType)\n        return right;\n    var leftModel = new Model(left.endMeta);\n    var rightModel = new Model(right.endMeta);\n    switch (leftType) {\n        case 'object': {\n            var leftObj = leftModel.asObject(left);\n            var rightObj = rightModel.asObject(right);\n            // Number of fields which are identical in left and right.\n            var identicalFieldCount = 0;\n            var leftFieldCount = Object.keys(leftObj.fields).length;\n            var rightFieldCount = Object.keys(rightObj.fields).length;\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\n                var leftVal = leftObj.fields[key];\n                if (leftVal) {\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                    if (rightObj.fields[key] === leftVal) {\n                        identicalFieldCount++;\n                    }\n                }\n            }\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n            return isIdentical ? left : right;\n        }\n        case 'array': {\n            var leftArr = leftModel.asArray(left);\n            var rightArr = rightModel.asArray(right);\n            if (leftArr.elements.length !== rightArr.elements.length) {\n                break;\n            }\n            var numRebased = 0;\n            for (var i = 0; i < rightArr.elements.length; i++) {\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\n                    numRebased++;\n                }\n            }\n            return numRebased === 0 ? left : right;\n        }\n        case 'null':\n        case 'boolean':\n        case 'number': {\n            if (unwrap(left) === unwrap(right))\n                return left;\n            break;\n        }\n        case 'string': {\n            var leftRaw = unwrap(left);\n            var rightRaw = unwrap(right);\n            if (leftRaw === rightRaw)\n                return left;\n            var result = rightModel.copyString(null);\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\n            if (0 < prefix) {\n                rightModel.stringAppendSlice(result, left, 0, prefix);\n            }\n            if (prefix < rightLen - suffix) {\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n            }\n            if (leftLen - suffix < leftLen) {\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n            }\n            var value = rightModel.finalize(result);\n            if (unwrap(value) !== rightRaw)\n                throw new Error('incorrect string rebase');\n            return value;\n        }\n    }\n    return right;\n}\nfunction applyPatch(left, patch, startMeta) {\n    var model = new Model(startMeta);\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmNyZW1lbnRhbC1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkM7QUFDcUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbURBQW1EO0FBQy9HLG1EQUFtRCxvQkFBb0I7QUFDdkUsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBLDJCQUEyQixtREFBWTtBQUN2QztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBWTtBQUNyQyx5QkFBeUIsbURBQVk7QUFDckMsMkJBQTJCLHFEQUFjO0FBQ3pDLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQixzREFBTztBQUM3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5jcmVtZW50YWwtcGF0Y2hlci5qcz84MjMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhdGNoZXIgfSBmcm9tICcuL2ludGVybmFsLXBhdGNoZXInO1xuaW1wb3J0IHsgdXRmOGNoYXJTaXplLCB1dGY4c3RyaW5nU2l6ZSwgY29tbW9uUHJlZml4LCBjb21tb25TdWZmaXggfSBmcm9tICcuL3V0ZjgnO1xudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKG1ldGEpIHtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXBXaXRoTWV0YSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydE1ldGEsIGVuZE1ldGEpIHtcbiAgICAgICAgaWYgKGVuZE1ldGEgPT09IHZvaWQgMCkgeyBlbmRNZXRhID0gdGhpcy5tZXRhOyB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogc3RhcnRNZXRhLCBlbmRNZXRhOiBlbmRNZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSB0aGlzLndyYXBXaXRoTWV0YSh2YWwsIHZhbHVlLnN0YXJ0TWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnb2JqZWN0JywgZmllbGRzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdmFsdWUuZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIF90aGlzLndyYXBXaXRoTWV0YShpdGVtLCB2YWx1ZS5zdGFydE1ldGEpOyB9KTtcbiAgICAgICAgICAgIHZhciBtZXRhcyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXRhOyB9KTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdhcnJheScsIGVsZW1lbnRzOiBlbGVtZW50cywgbWV0YXM6IG1ldGFzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXG4gICAgICAgICAgICAgICAgdXNlczogW10sXG4gICAgICAgICAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXG4gICAgICAgICAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0Zyb21QYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgICB2YXIgc3RyID0ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgICAgICBwYXJ0LnVzZXMucHVzaChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0S2V5cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmNvbnRlbnQuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEZpZWxkID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqLmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5R2V0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyLmVsZW1lbnRzW2lkeF07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEoY29udGVudCk7XG4gICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5tYXJrQ2hhbmdlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnVwZGF0ZUVuZE1ldGEgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGVudC5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGNvbnRlbnQuZWxlbWVudHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBPYmplY3QudmFsdWVzKGNvbnRlbnQuZmllbGRzKTsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGZpZWxkczoge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XG4gICAgICAgIHZhciBtZXRhcyA9IGFyciA/IGFyci5tZXRhcyA6IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIG1ldGFzOiBtZXRhc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdFNldEZpZWxkID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZmllbGRzW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xuICAgICAgICB2YXIgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICAgICAgKF9hID0gdGFyZ2V0LmVsZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBhcnIuZWxlbWVudHMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgaWYgKHNhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgKF9iID0gdGFyZ2V0Lm1ldGFzKS5wdXNoLmFwcGx5KF9iLCBhcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHN0ci5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRQYXJ0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFydCkge1xuICAgICAgICB0YXJnZXQucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5yZXNvbHZlU3RyaW5nUGFydCA9IGZ1bmN0aW9uIChzdHIsIGZyb20sIGxlbikge1xuICAgICAgICBpZiAobGVuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc3RyLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIHBlcmZlY3QhXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbiA8IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcGFydCBvZiB0aGlzIGNodW5rLiBXZSBub3cgbmVlZCB0byBzcGxpdCBpdCB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHMnKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zcGxpdFN0cmluZyA9IGZ1bmN0aW9uIChwYXJ0LCBpZHgpIHtcbiAgICAgICAgdmFyIGxlZnRWYWx1ZTtcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWU7XG4gICAgICAgIHZhciBsZWZ0U2l6ZSA9IGlkeDtcbiAgICAgICAgdmFyIHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcbiAgICAgICAgLy8gaWR4IGlzIGhlcmUgaW4gVVRGLTggaW5kZXgsIG5vdCBjb2RlcG9pbnQgaW5kZXguXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgd2UgbWlnaHQgdG8gYWRqdXN0IGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplID09PSA0KVxuICAgICAgICAgICAgICAgICAgICBpZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpO1xuICAgICAgICByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgICAgICB2YXIgbmV3UGFydCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxuICAgICAgICAgICAgdXRmOHNpemU6IHJpZ2h0U2l6ZSxcbiAgICAgICAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxuICAgICAgICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcbiAgICAgICAgICAgIGVuZE1ldGE6IHBhcnQuZW5kTWV0YVxuICAgICAgICB9O1xuICAgICAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xuICAgICAgICBwYXJ0LnV0ZjhzaXplID0gbGVmdFNpemU7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJ0LnVzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdXNlID0gX2FbX2ldO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgcGFydC5cbiAgICAgICAgICAgIHZhciBpZHhfMSA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgaWYgKGlkeF8xID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZzogbWlzbWF0Y2ggYmV0d2VlbiBzdHJpbmcgcGFydHMgYW5kIHVzZS4nKTtcbiAgICAgICAgICAgIHVzZS5wYXJ0cy5zcGxpY2UoaWR4XzEgKyAxLCAwLCBuZXdQYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpO1xuICAgICAgICB2YXIgZmlyc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIDAsIGxlZnQpO1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbi8vIFR1cm5zIGEgbmF0aXZlIEphdmFTY3JpcHQgb2JqZWN0IGludG8gYSBWYWx1ZSB3aXRoIGEgZ2l2ZW4gb3JpZ2luLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xuICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogbWV0YSwgZW5kTWV0YTogbWV0YSB9O1xufVxuLy8gQ29udmVydHMgYSBWYWx1ZSBpbnRvIGEgbmF0aXZlIEphdmFTY3JpcHQgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLmRhdGEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBjb250ZW50ID0gdmFsdWUuY29udGVudDtcbiAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmVzdWx0ID0gY29udGVudC5wYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudmFsdWU7IH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHVud3JhcCh2YWwpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1bndyYXAodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgVmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb250ZW50KVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKVxuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmRhdGE7XG59XG4vLyBVcGRhdGVzIHRoZSBgcmlnaHRgIHZhbHVlIHN1Y2ggdGhhdCBpdCByZXVzZXMgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBgbGVmdGAgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gcmViYXNlVmFsdWUobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xuICAgIHZhciByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSlcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIHZhciBsZWZ0TW9kZWwgPSBuZXcgTW9kZWwobGVmdC5lbmRNZXRhKTtcbiAgICB2YXIgcmlnaHRNb2RlbCA9IG5ldyBNb2RlbChyaWdodC5lbmRNZXRhKTtcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0T2JqID0gbGVmdE1vZGVsLmFzT2JqZWN0KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgZmllbGRzIHdoaWNoIGFyZSBpZGVudGljYWwgaW4gbGVmdCBhbmQgcmlnaHQuXG4gICAgICAgICAgICB2YXIgaWRlbnRpY2FsRmllbGRDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHJpZ2h0T2JqLmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgcmlnaHRWYWwgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpY2FsRmllbGRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0QXJyID0gbGVmdE1vZGVsLmFzQXJyYXkobGVmdCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRBcnIgPSByaWdodE1vZGVsLmFzQXJyYXkocmlnaHQpO1xuICAgICAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1SZWJhc2VkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUmViYXNlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0UmF3ID0gdW53cmFwKGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb21tb25TdWZmaXgobGVmdFJhdywgcmlnaHRSYXcsIHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xuICAgICAgICAgICAgaWYgKDAgPCBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmaXggPCByaWdodExlbiAtIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4pIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByaWdodE1vZGVsLmZpbmFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZScpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaWdodDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoc3RhcnRNZXRhKTtcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XG4gICAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/mendoza/lib/esm/incremental-patcher.js\n");

/***/ }),

/***/ "../node_modules/mendoza/lib/esm/index.js":
/*!************************************************!*\
  !*** ../node_modules/mendoza/lib/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"../node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"../node_modules/mendoza/lib/esm/simple-patcher.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVEO0FBQ2Y7QUFDTTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmRleC5qcz9mMjc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGluY3JlbWVudGFsXzEgZnJvbSAnLi9pbmNyZW1lbnRhbC1wYXRjaGVyJztcbmV4cG9ydCB7IGluY3JlbWVudGFsXzEgYXMgaW5jcmVtZW50YWwgfTtcbmV4cG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tICcuL3NpbXBsZS1wYXRjaGVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/mendoza/lib/esm/index.js\n");

/***/ }),

/***/ "../node_modules/mendoza/lib/esm/internal-patcher.js":
/*!***********************************************************!*\
  !*** ../node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\n    'Value',\n    'Copy',\n    'Blank',\n    'ReturnIntoArray',\n    'ReturnIntoObject',\n    'ReturnIntoObjectSameKey',\n    'PushField',\n    'PushElement',\n    'PushParent',\n    'Pop',\n    'PushFieldCopy',\n    'PushFieldBlank',\n    'PushElementCopy',\n    'PushElementBlank',\n    'ReturnIntoObjectPop',\n    'ReturnIntoObjectSameKeyPop',\n    'ReturnIntoArrayPop',\n    'ObjectSetFieldValue',\n    'ObjectCopyField',\n    'ObjectDeleteField',\n    'ArrayAppendValue',\n    'ArrayAppendSlice',\n    'StringAppendString',\n    'StringAppendSlice'\n];\nvar Patcher = /** @class */ (function () {\n    function Patcher(model, root, patch) {\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n    }\n    Patcher.prototype.read = function () {\n        return this.patch[this.i++];\n    };\n    Patcher.prototype.process = function () {\n        this.inputStack.push({ value: this.root });\n        this.outputStack.push({ value: this.root });\n        for (; this.i < this.patch.length;) {\n            var opcode = this.read();\n            var op = OPS[opcode];\n            if (!op)\n                throw new Error(\"Unknown opcode: \" + opcode);\n            var processor = \"process\" + op;\n            this[processor].apply(this);\n        }\n        var entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    };\n    Patcher.prototype.inputEntry = function () {\n        return this.inputStack[this.inputStack.length - 1];\n    };\n    Patcher.prototype.inputKey = function (entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    };\n    Patcher.prototype.outputEntry = function () {\n        return this.outputStack[this.outputStack.length - 1];\n    };\n    Patcher.prototype.outputArray = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputObject = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputString = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.finalizeOutput = function (entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        }\n        else {\n            return entry.value;\n        }\n    };\n    // Processors:\n    Patcher.prototype.processValue = function () {\n        var value = this.model.wrap(this.read());\n        this.outputStack.push({ value: value });\n    };\n    Patcher.prototype.processCopy = function () {\n        var input = this.inputEntry();\n        this.outputStack.push({ value: input.value });\n    };\n    Patcher.prototype.processBlank = function () {\n        this.outputStack.push({ value: null });\n    };\n    Patcher.prototype.processReturnIntoArray = function () {\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    };\n    Patcher.prototype.processReturnIntoObject = function () {\n        var key = this.read();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    };\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\n        var input = this.inputEntry();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    };\n    Patcher.prototype.processPushField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({ value: value, key: key });\n    };\n    Patcher.prototype.processPushElement = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({ value: value });\n    };\n    Patcher.prototype.processPop = function () {\n        this.inputStack.pop();\n    };\n    Patcher.prototype.processPushFieldCopy = function () {\n        this.processPushField();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushFieldBlank = function () {\n        this.processPushField();\n        this.processBlank();\n    };\n    Patcher.prototype.processPushElementCopy = function () {\n        this.processPushElement();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushElementBlank = function () {\n        this.processPushElement();\n        this.processBlank();\n    };\n    Patcher.prototype.processReturnIntoObjectPop = function () {\n        this.processReturnIntoObject();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoArrayPop = function () {\n        this.processReturnIntoArray();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectSetFieldValue = function () {\n        this.processValue();\n        this.processReturnIntoObject();\n    };\n    Patcher.prototype.processObjectCopyField = function () {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectDeleteField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    };\n    Patcher.prototype.processArrayAppendValue = function () {\n        var value = this.model.wrap(this.read());\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    };\n    Patcher.prototype.processArrayAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputArray();\n        var val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    };\n    Patcher.prototype.processStringAppendString = function () {\n        var value = this.model.wrap(this.read());\n        var str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    };\n    Patcher.prototype.processStringAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputString();\n        var val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    };\n    return Patcher;\n}());\n\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbnRlcm5hbC1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pELGdDQUFnQyxrQkFBa0I7QUFDbEQsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW50ZXJuYWwtcGF0Y2hlci5qcz9hNTAwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBPUFMgPSBbXG4gICAgJ1ZhbHVlJyxcbiAgICAnQ29weScsXG4gICAgJ0JsYW5rJyxcbiAgICAnUmV0dXJuSW50b0FycmF5JyxcbiAgICAnUmV0dXJuSW50b09iamVjdCcsXG4gICAgJ1JldHVybkludG9PYmplY3RTYW1lS2V5JyxcbiAgICAnUHVzaEZpZWxkJyxcbiAgICAnUHVzaEVsZW1lbnQnLFxuICAgICdQdXNoUGFyZW50JyxcbiAgICAnUG9wJyxcbiAgICAnUHVzaEZpZWxkQ29weScsXG4gICAgJ1B1c2hGaWVsZEJsYW5rJyxcbiAgICAnUHVzaEVsZW1lbnRDb3B5JyxcbiAgICAnUHVzaEVsZW1lbnRCbGFuaycsXG4gICAgJ1JldHVybkludG9PYmplY3RQb3AnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCcsXG4gICAgJ1JldHVybkludG9BcnJheVBvcCcsXG4gICAgJ09iamVjdFNldEZpZWxkVmFsdWUnLFxuICAgICdPYmplY3RDb3B5RmllbGQnLFxuICAgICdPYmplY3REZWxldGVGaWVsZCcsXG4gICAgJ0FycmF5QXBwZW5kVmFsdWUnLFxuICAgICdBcnJheUFwcGVuZFNsaWNlJyxcbiAgICAnU3RyaW5nQXBwZW5kU3RyaW5nJyxcbiAgICAnU3RyaW5nQXBwZW5kU2xpY2UnXG5dO1xudmFyIFBhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0Y2hlcihtb2RlbCwgcm9vdCwgcGF0Y2gpIHtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLnBhdGNoID0gcGF0Y2g7XG4gICAgfVxuICAgIFBhdGNoZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGNoW3RoaXMuaSsrXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcbiAgICAgICAgZm9yICg7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIG9wY29kZSA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgdmFyIG9wID0gT1BTW29wY29kZV07XG4gICAgICAgICAgICBpZiAoIW9wKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3Bjb2RlOiBcIiArIG9wY29kZSk7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gXCJwcm9jZXNzXCIgKyBvcDtcbiAgICAgICAgICAgIHRoaXNbcHJvY2Vzc29yXS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFN0YWNrW3RoaXMuaW5wdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLmlucHV0S2V5ID0gZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHtcbiAgICAgICAgaWYgKCFlbnRyeS5rZXlzKSB7XG4gICAgICAgICAgICBlbnRyeS5rZXlzID0gdGhpcy5tb2RlbC5vYmplY3RHZXRLZXlzKGVudHJ5LnZhbHVlKS5zb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LmtleXNbaWR4XTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRTdGFja1t0aGlzLm91dHB1dFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICAgICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weU9iamVjdChlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICAgICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5U3RyaW5nKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLmZpbmFsaXplT3V0cHV0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS53cml0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5hbGl6ZShlbnRyeS53cml0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHJvY2Vzc29yczpcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IGlucHV0LnZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGtleSwgcmVzdWx0KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGtleToga2V5IH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRmllbGRCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQmxhbmsoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3RTZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NWYWx1ZSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0Q29weUZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NTdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRjaGVyO1xufSgpKTtcbmV4cG9ydCB7IFBhdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/mendoza/lib/esm/internal-patcher.js\n");

/***/ }),

/***/ "../node_modules/mendoza/lib/esm/simple-patcher.js":
/*!*********************************************************!*\
  !*** ../node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"../node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"../node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = {\n    wrap: function (data) {\n        return data;\n    },\n    finalize: function (b) {\n        if (Array.isArray(b)) {\n            return b;\n        }\n        else {\n            return b.data;\n        }\n    },\n    markChanged: function (value) {\n        return value;\n    },\n    objectGetKeys: function (value) {\n        return Object.keys(value);\n    },\n    objectGetField: function (value, key) {\n        return value[key];\n    },\n    arrayGetElement: function (value, idx) {\n        return value[idx];\n    },\n    copyObject: function (value) {\n        var res = {\n            type: 'object',\n            data: {}\n        };\n        if (value !== null) {\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                res.data[key] = val;\n            }\n        }\n        return res;\n    },\n    copyArray: function (value) {\n        if (value === null)\n            return [];\n        return value.slice();\n    },\n    copyString: function (value) {\n        return {\n            type: 'string',\n            data: value === null ? '' : value\n        };\n    },\n    objectSetField: function (target, key, value) {\n        target.data[key] = value;\n    },\n    objectDeleteField: function (target, key) {\n        delete target.data[key];\n    },\n    arrayAppendValue: function (target, value) {\n        target.push(value);\n    },\n    arrayAppendSlice: function (target, source, left, right) {\n        target.push.apply(target, source.slice(left, right));\n    },\n    stringAppendSlice: function (target, source, left, right) {\n        var sourceString = source;\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    },\n    stringAppendValue: function (target, value) {\n        target.data += value;\n    }\n};\n// Applies a patch on a JavaScript object.\nfunction applyPatch(left, patch) {\n    var root = left; // No need to wrap because the representation is the same.\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9zaW1wbGUtcGF0Y2hlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDSDtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsdURBQWdCO0FBQ3RDLHVCQUF1Qix1REFBZ0I7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUJBQXFCO0FBQ3JCLHNCQUFzQixzREFBTztBQUM3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vc2ltcGxlLXBhdGNoZXIuanM/MDkwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcbmltcG9ydCB7IHV0ZjhyZXNvbHZlSW5kZXggfSBmcm9tICcuL3V0ZjgnO1xudmFyIE1vZGVsID0ge1xuICAgIHdyYXA6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiLmRhdGE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtDaGFuZ2VkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgb2JqZWN0R2V0S2V5czogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgfSxcbiAgICBvYmplY3RHZXRGaWVsZDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgfSxcbiAgICBhcnJheUdldEVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtpZHhdO1xuICAgIH0sXG4gICAgY29weU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBjb3B5QXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH0sXG4gICAgY29weVN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0U2V0RmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgb2JqZWN0RGVsZXRlRmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LmRhdGFba2V5XTtcbiAgICB9LFxuICAgIGFycmF5QXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHZhbHVlKTtcbiAgICB9LFxuICAgIGFycmF5QXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2guYXBwbHkodGFyZ2V0LCBzb3VyY2Uuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICB9LFxuICAgIHN0cmluZ0FwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBzb3VyY2VTdHJpbmcgPSBzb3VyY2U7XG4gICAgICAgIHZhciBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xuICAgICAgICB2YXIgcmlnaHRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgcmlnaHQsIGxlZnRQb3MpO1xuICAgICAgICB0YXJnZXQuZGF0YSArPSBzb3VyY2VTdHJpbmcuc2xpY2UobGVmdFBvcywgcmlnaHRQb3MpO1xuICAgIH0sXG4gICAgc3RyaW5nQXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5kYXRhICs9IHZhbHVlO1xuICAgIH1cbn07XG4vLyBBcHBsaWVzIGEgcGF0Y2ggb24gYSBKYXZhU2NyaXB0IG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoKSB7XG4gICAgdmFyIHJvb3QgPSBsZWZ0OyAvLyBObyBuZWVkIHRvIHdyYXAgYmVjYXVzZSB0aGUgcmVwcmVzZW50YXRpb24gaXMgdGhlIHNhbWUuXG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihNb2RlbCwgcm9vdCwgcGF0Y2gpO1xuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1wYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/mendoza/lib/esm/simple-patcher.js\n");

/***/ }),

/***/ "../node_modules/mendoza/lib/esm/utf8.js":
/*!***********************************************!*\
  !*** ../node_modules/mendoza/lib/esm/utf8.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; }\n/* harmony export */ });\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    }\n    else if (code >> 11) {\n        return 3;\n    }\n    else if (code >> 7) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    var b = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.codePointAt(i);\n        var size = utf8charSize(code);\n        if (size == 4)\n            i++;\n        b += size;\n    }\n    return b;\n}\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nfunction utf8resolveIndex(str, idx, start) {\n    if (start === void 0) { start = 0; }\n    var byteCount = start;\n    var ucsIdx = 0;\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n        var code = str.codePointAt(ucsIdx);\n        var size = utf8charSize(code);\n        if (size === 4)\n            ucsIdx++; // Surrogate pair.\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    var len = Math.min(str.length, str2.length);\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(i);\n        var bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix) {\n    if (prefix === void 0) { prefix = 0; }\n    var len = Math.min(str.length, str2.length) - prefix;\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(str.length - 1 - i);\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS91dGY4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vdXRmOC5qcz80N2M1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiB1dGY4Y2hhclNpemUoY29kZSkge1xuICAgIGlmIChjb2RlID4+IDE2KSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID4+IDExKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID4+IDcpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdXRmOHN0cmluZ1NpemUoc3RyKSB7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT0gNClcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgYiArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8qKiBDb252ZXJ0cyBhbiBVVEYtOCBieXRlIGluZGV4IGludG8gYSBVQ1MtMiBpbmRleC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4cmVzb2x2ZUluZGV4KHN0ciwgaWR4LCBzdGFydCkge1xuICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgIHZhciBieXRlQ291bnQgPSBzdGFydDtcbiAgICB2YXIgdWNzSWR4ID0gMDtcbiAgICBmb3IgKHVjc0lkeCA9IHN0YXJ0OyBieXRlQ291bnQgPCBpZHg7IHVjc0lkeCsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCk7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gNClcbiAgICAgICAgICAgIHVjc0lkeCsrOyAvLyBTdXJyb2dhdGUgcGFpci5cbiAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiB1Y3NJZHg7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tbW9uUHJlZml4KHN0ciwgc3RyMikge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCk7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICAgICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblN1ZmZpeChzdHIsIHN0cjIsIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAwOyB9XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeDtcbiAgICB2YXIgYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIHZhciBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoc3RyMi5sZW5ndGggLSAxIC0gaSk7XG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/mendoza/lib/esm/utf8.js\n");

/***/ }),

/***/ "../node_modules/throttle-debounce/cjs/index.js":
/*!******************************************************!*\
  !*** ../node_modules/throttle-debounce/cjs/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\nexports.debounce = debounce;\nexports.throttle = throttle;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzP2ZlOWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQsbm8tcGFyYW0tcmVhc3NpZ24sbm8tc2hhZG93ICovXG5cbi8qKlxuICogVGhyb3R0bGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nXG4gKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSAgICBkZWxheSAtICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZC4gSWYgbm9UcmFpbGluZyBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgLSAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSAtIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUgKGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlKSB7XG4gIC8qXG4gICAqIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XG4gICAqIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuICAgKiBkZWJvdW5jZSBtb2Rlcy5cbiAgICovXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfSAvLyBgbm9UcmFpbGluZ2AgZGVmYXVsdHMgdG8gZmFsc3kuXG5cblxuICBpZiAodHlwZW9mIG5vVHJhaWxpbmcgIT09ICdib29sZWFuJykge1xuICAgIGRlYm91bmNlTW9kZSA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbm9UcmFpbGluZztcbiAgICBub1RyYWlsaW5nID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qXG4gICAqIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcbiAgICogZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2BcbiAgICogaXMgZXhlY3V0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzXyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3VtZW50c19bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGxhc3RFeGVjO1xuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuXG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzXyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAqIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGltZW91dElEID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCkge1xuICAgICAgLypcbiAgICAgICAqIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxuICAgICAgICogYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRocm90dGxlIG1vZGUsIGlmIGBkZWxheWAgdGltZSBoYXMgYmVlbiBleGNlZWRlZCwgZXhlY3V0ZVxuICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZXhlYygpO1xuICAgIH0gZWxzZSBpZiAobm9UcmFpbGluZyAhPT0gdHJ1ZSkge1xuICAgICAgLypcbiAgICAgICAqIEluIHRyYWlsaW5nIHRocm90dGxlIG1vZGUsIHNpbmNlIGBkZWxheWAgdGltZSBoYXMgbm90IGJlZW5cbiAgICAgICAqIGV4Y2VlZGVkLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYGRlbGF5YCBtcyBhZnRlciBtb3N0XG4gICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlXG4gICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICpcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvXG4gICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgKi9cbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZGVib3VuY2VNb2RlID8gY2xlYXIgOiBleGVjLCBkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCA/IGRlbGF5IC0gZWxhcHNlZCA6IGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICB3cmFwcGVyLmNhbmNlbCA9IGNhbmNlbDsgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuXG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbi8qKlxuICogRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxuICogZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXG4gKiB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gICBkZWxheSAtICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgW2F0QmVnaW5dIC0gICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRCZWdpbiBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSBkZWJvdW5jZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgYXRCZWdpbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyB0aHJvdHRsZShkZWxheSwgYXRCZWdpbiwgZmFsc2UpIDogdGhyb3R0bGUoZGVsYXksIGNhbGxiYWNrLCBhdEJlZ2luICE9PSBmYWxzZSk7XG59XG5cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/throttle-debounce/cjs/index.js\n");

/***/ })

}]);